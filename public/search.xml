<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ViewGroup一些相关的类]]></title>
    <url>%2F2018%2F06%2F26%2FewGroup%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[setWillNotDraw() 在viewgroup初始化的时候，它调用了一个私有方法：initViewGroup --&gt; setFlags（WILLL_NOT_DRAW,DRAW_MASK)，不会调用ondraw（）方法，自定义viewgroup时候需要setWillNotDraw(false)； descendantfocusability viewgroup控件在代码中或者xml中能设置该属性： FOCUS_BEFORE_DESCENDANTS ViewGroup本身先对焦点进行处理，如果没有处理则分发给child View进行处理 FOCUS_AFTER_DESCENDANTS 先分发给Child View进行处理，如果所有的Child View都没有处理，则自己再处理 FOCUS_BLOCK_DESCENDANTS ViewGroup本身进行处理，不管是否处理成功，都不会分发给ChildView进行处理 ViewCompat 这个是解决版本兼容性的 ViewPager内部的view根据位置绘制的，缓存多少个就在相邻位置绘制多少个]]></content>
  </entry>
  <entry>
    <title><![CDATA[gradle 笔记01]]></title>
    <url>%2F2018%2F06%2F25%2Fradle-%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[任务的按照dofirst{}dolast{}顺序执行&lt;&lt; 符号是dolast的别名ext是创建的任务的额外任务属性]]></content>
  </entry>
  <entry>
    <title><![CDATA[Canvan的几个方法含义]]></title>
    <url>%2F2018%2F06%2F11%2Fnvan%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[save保存当前绘制属性，画布坐标变化之前的状态 restore绘制属性回退到上一个保存堆栈的上一个状态]]></content>
  </entry>
  <entry>
    <title><![CDATA[Shader]]></title>
    <url>%2F2018%2F06%2F11%2Fader%2F</url>
    <content type="text"><![CDATA[着色器 LinearGradient 线性变色，Shader shader = new LinearGradient(0, 0, 100, 100, Color.RED, Color.GREEN, Shader.TileMode.REPEAT); 参数：第一个是x开始坐标，第二个是y开始坐标，三、四结束x、y坐标，左边是根据view的坐标系开始计算的，五是模式：重复还是扩展、镜像 RadialGradient辐射渐变，由一中心点渐变 SweepGradient 像雷达一样 BitmapShader 图像BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY) ComposeShader多个着色器组合使用 new ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER);]]></content>
  </entry>
  <entry>
    <title><![CDATA[手势监听]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%8A%BF%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[手势监听 VelocityTracker加速度监听 obtain()：实例化 addMovement(MotionEvent event)：添加事件 recycle()：回收]]></content>
  </entry>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2F2018%2F05%2F30%2Fl%2F</url>
    <content type="text"><![CDATA[https://www.studytutorial.in/android-sending-xml-or-soap-rest-api-request-using-okhttp-tutorial]]></content>
  </entry>
  <entry>
    <title><![CDATA[WorkManager]]></title>
    <url>%2F2018%2F05%2F29%2ForkManager%2F</url>
    <content type="text"><![CDATA[WorkManager 主要的类 WorkManager：管理任务，开启任务 WorkManager 方法WorkManager getInstance()： 获取实例 initialize(@NonNull Context context, @NonNull Configuration configuration)： 获取实例，参数二配置线程池 enqueue(@NonNull WorkRequest... workRequest)： 添加后台任务 enqueue(@NonNull List&lt;? extends WorkRequest&gt; baseWork)： 添加后台任务 WorkContinuation beginWith(@NonNull OneTimeWorkRequest...work)： 开启不需要重复的任务，它只执行一遍，返回值WorkContinuation 是用来开启任务链的； 能够与其他的进行then、combine操作 WorkContinuation beginWith(@NonNull List&lt;OneTimeWorkRequest&gt; work)； 开启一组的上述任务 WorkContinuation beginUniqueWork( @NonNull String uniqueWorkName, @NonNull ExistingWorkPolicy existingWorkPolicy, @NonNull OneTimeWorkRequest... work) ： 该方法第一个参数是任务名称，名称是唯一的不能够重复；第二个参数ExistingWorkPOneTimeWorkRequestolicy是用来判断如果出现了重复的，是替换还是追加、还是不理会 继续保持当前的任务目标不变； cancelWorkById(@NonNull UUID id)： 根据uuid去取消任务，但是方法的调用不一定回起作用，如果正在执行，那么将不会取消，任务会正常的去完成。 void cancelAllWorkByTag(@NonNull String tag)： 与上相似。 void cancelUniqueWork(@NonNull String uniqueWorkName) 字面意思。 LiveData&lt;WorkStatus&gt; getStatusById(@NonNull UUID id); 能够监听任务的完成情况。 LiveData&lt;List&lt;WorkStatus&gt;&gt; getStatusesByTag(@NonNull String tag)： 字面。 LiveData&lt;List&lt;WorkStatus&gt;&gt; getStatusesForUniqueWork( @NonNull String uniqueWorkName)： 字面。 SynchronousWorkManager synchronous()： 返回的对象方法什么的跟原来的WorkManager方法都差不多，这个是同步方法，不能在主线程中运行。在子线程中使用，能直接知道是否添加成功 WorkRequest 任务请求 OneTimeWorkRequest 不重复的请求，执行一次； PeriodicWorkRequest重复执行 WorkSpec存入数据库的一些任务调度信息，时间、任务信息等 Worker 任务基本单元，有已经实现好的几个类，自己实现只需要复写 dowork就可以，类单独写，不能是内部类实现，否则实例化不了。通过get方法能获取到传递的所有信息数据。下列出已经实现的该类的对象。 CombineContinuationsWorker工作任务流组合，能够像链条一样 ConstraintTrackingWorker当约束符合条件,可以传如参数（类名称），通过不同参数实现不同代理 Constraints 约束，设定任务在什么系统的什么情况下能够启动 mRequiredNetworkType什么网络条件下启动 mRequiresCharging 充电 mRequiresDeviceIdle休眠 mRequiresBatteryNotLow电量不高 mRequiresStorageNotLow内存不高 mContentUriTriggersuri触发启动]]></content>
  </entry>
  <entry>
    <title><![CDATA[定时任务的一个库]]></title>
    <url>%2F2018%2F05%2F29%2F%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%93%2F</url>
    <content type="text"><![CDATA[地址 https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/能够根据不同版本去选择不同方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[书签]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt; Bookmarks Bookmarks 书签栏 Android Api Guide 中国软件与技术服务股份有限公司邮件登录 okhttp3 (OkHttp 3.4.1 API) Realm: Create reactive mobile apps in a fraction of the time HTML/CSS Flex 布局教程：实例篇 - 阮一峰的网络日志 Flex 布局教程：语法篇 - 阮一峰的网络日志 GitHub - googlesamples/android-architecture: A collection of samples to discuss and showcase different architectural tools and patterns for Android apps. GitHub - googlesamples/android-architecture-components: Samples for Android Architecture Components. 一个github上不错的工具类分享 - CSDN博客 HenCoder「仿写酷界面」活动——征稿 Most Popular - LottieFiles 我所经历的Android面试|掘金技术征文 - 掘金 GitHub - alibaba/ARouter: An android router middleware that help app navigating to activities and custom services. GitHub - CyC2018/Interview-Notebook: 技术面试需要掌握的基础知识整理，欢迎编辑~ Android 知识体系脑图「android篇」 | bug 鸣泣之时 ［Android基础］Android总结篇 - CSDN博客 10个优秀个android项目，精选|快速开发 – Android开发中文站 AndroidXRef Android 开源项目集合 下班后，可以通过什么方式赚钱？ - 简书 Android开发中文站–关注Android，关注开发者 Gradle 教程 - Android Studio 安卓开发者社区 分享文件 | Android官方培训课程中文版(v0.9.7) 央视App]]></content>
  </entry>
  <entry>
    <title><![CDATA[产品基本流程]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[产品定位 需求分析 需求筛选 商业价值 5W2H?what,who,where,when,why? how,how much?]]></content>
  </entry>
  <entry>
    <title><![CDATA[vpn]]></title>
    <url>%2F2018%2F05%2F25%2Fpn%2F</url>
    <content type="text"><![CDATA[搬瓦工账号：513952947@qq.com密码；** w服务器地址 服务器安装： wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh 安装wget yum -y install wget 更改运行脚本权限 chmod +x shadowsocks-all.sh 运行脚本 ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 保存信息 保存服务ip端口号密码等信息 终端软件安装 ios：https://itunes.apple.com/us/app/wingy-proxy-for-http-s-socks5/id1178584911?mt=8 Android：https://github.com/shadowsocks/shadowsocks-android/releases windows：https://github.com/shadowsocks/shadowsocks-windows/releases ubuntu：sudo apt-get update sudo apt-get install python-pip sudo apt-get install python-setuptools m2crypto pip install shadowsocks sudo apt install shadowsocks sslocal -s [ip地址] -p [端口号] -k [密码] -l [1080本地端口] -t [超时] -m aes-256-cfb]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 矢量图动画]]></title>
    <url>%2F2018%2F05%2F25%2Fndroid-%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[矢量图来源 在Android中正常的是： f &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ...&gt; &lt;path/&gt; &lt;/vector&gt; vector标签中包含路径，动画就需要使用&lt;group&gt; path... &lt;/group&gt;包裹路径，并对包裹路径的group设置动画属性来控制该标签内的路径变化； xml实现动画方式 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;vector图片&quot;&gt; &lt;target android:animation=&quot;@animator/动画xml&quot; android:name=&quot;要做动画的path、在group中path的定义名称&quot;/&gt; &lt;target android:name=&quot;要做动画的path&quot; android:animation=&quot;@animator/smile_morph&quot;/&gt; &lt;/animated-vector&gt; AnimatedVectorDrawable smileDrawable = (AnimatedVectorDrawable) imageView.getDrawable(); smileDrawable.start();调用 java代码实现方式 矢量图动画网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[Palette]]></title>
    <url>%2F2018%2F05%2F25%2Falette%2F</url>
    <content type="text"><![CDATA[Palette‘com.android.support:palette-v7:27.1.1’ Vibrant: 亮色 Vibrant dark: 深亮色 Vibrant light: 浅亮色 Muted: 暗色 Muted dark: 深暗色 Muted light: 浅暗色]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>颜色提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android statusBar]]></title>
    <url>%2F2018%2F05%2F25%2Fdroid-statusBar%2F</url>
    <content type="text"><![CDATA[View mDecorView; private static String TAG = &quot;StatusBarActivity&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mDecorView = findViewById(android.R.id.content); mDecorView.setOnSystemUiVisibilityChangeListener(new View.OnSystemUiVisibilityChangeListener() { @Override public void onSystemUiVisibilityChange(int visibility) { // Note that system bars will only be &quot;visible&quot; if none of the // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set. if ((visibility &amp; View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) { // TODO: The system bars are visible. Make any desired // adjustments to your UI, such as showing the action bar or // other navigational controls. } else { // TODO: The system bars are NOT visible. Make any desired // adjustments to your UI, such as hiding the action bar or // other navigational controls. } } }); showSystemUI(); setContentView(R.layout.activity_status_bar); findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { hideSystemUI(); } }); } private void showSystemUI() { //显示状态栏 mDecorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); } private void hideSystemUI() { // Set the IMMERSIVE flag. 设置沉浸式 //SYSTEM_UI_FLAG_IMMERSIVE_STICKY 内滑显示状态栏 会自动消失 //SYSTEM_UI_FLAG_IMMERSIVE 内滑显示状态栏 不会自动消失 // Set the content to appear under the system bars so that the content // doesn&apos;t resize when the system bars hide and show. mDecorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>statusBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FileProvider]]></title>
    <url>%2F2018%2F05%2F24%2FFileProvider%2F</url>
    <content type="text"><![CDATA[为了给应用程序定义一个FileProvider，需要在Manifest清单文件中定义一个entry，该entry指明了需要使用的创建Content URI的Authority。此外，还需要一个XML文件的文件名，该XML文件指定了我们的应用可以共享的目录路径。 下例展示了如何在清单文件中添加标签，来指定FileProvider类，Authority及XML文件名： &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapp&quot;&gt; &lt;application ...&gt; &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.example.myapp.fileprovider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/filepaths&quot; /&gt; &lt;/provider&gt; ... &lt;/application&gt; &lt;/manifest&gt; 在“res/xml/”下创建文件“filepaths.xml”。在这个文件中，为每一个想要共享目录添加一个XML标签 &lt;paths&gt; &lt;files-path path=&quot;images/&quot; name=&quot;myimages&quot; /&gt; &lt;/paths&gt; 标签共享的是在我们应用的内部存储中“files/”目录下的目录。“path”属性字段指出了该子目录为“files/”目录下的子目录“images/”。“name”属性字段告知FileProvider在“files/images/”子目录中的文件的Content URI添加路径分段（path segment）标记：“myimages”。 标签可以有多个子标签，每一个子标签用来指定不同的共享目录。除了标签，还可以使用来共享位于外部存储的目录；另外，标签用来共享在内部缓存目录下的子目录。 在文件分享是时调用给与临时的权限： Intent.addFlags( Intent.FLAG_GRANT_READ_URI_PERMISSION);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>FileProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络连接检测]]></title>
    <url>%2F2018%2F05%2F24%2Fdroid-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[检测是否连接 private static final String DEBUG_TAG = &quot;NetworkStatusExample&quot;; ConnectivityManager connMgr = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI); boolean isWifiConn = networkInfo.isConnected(); networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); boolean isMobileConn = networkInfo.isConnected(); Log.d(DEBUG_TAG, &quot;Wifi connected: &quot; + isWifiConn); Log.d(DEBUG_TAG, &quot;Mobile connected: &quot; + isMobileConn);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 打印当前行数和名称方法]]></title>
    <url>%2F2018%2F05%2F24%2Fdroid-%E6%89%93%E5%8D%B0%E5%BD%93%E5%89%8D%E8%A1%8C%E6%95%B0%E5%92%8C%E5%90%8D%E7%A7%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获取类名称 行数 public static String getFunctionName() { StackTraceElement[] sts = Thread.currentThread().getStackTrace(); if (sts == null) { return null; } for (StackTraceElement st : sts) { if (st.isNativeMethod()) { continue; } if (st.getClassName().equals(Thread.class.getName())) { continue; } if (st.getClassName().equals(Logger.class.getName())) { continue; } return &quot;[&quot; + Thread.currentThread().getName() + &quot;(&quot; + Thread.currentThread().getId() + &quot;): &quot; + st.getFileName() + &quot;:&quot; + st.getLineNumber() + &quot;]&quot;; } return null; } 打印超多数字public static void i(String msg) { if (debug) { String message = createMessage(msg); if (message.length() &gt; 4000) { int chunkCount = message.length() / 4000; // integer division for (int i = 0; i &lt;= chunkCount; i++) { int max = 4000 * (i + 1); if (max &gt;= message.length()) { Log.i(tag,message.substring(4000 * i)+&quot;\n&quot;); } else { Log.v(tag, message.substring(4000 * i, max)+&quot;\n&quot;); } } }else { Log.i(tag, message); } } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局域网内 ip连接]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85-ip%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[转载https://blog.csdn.net/jspping/article/details/64438515在当今的互联网时代，很多互联网公司、方案公司、智能设备公司或多或少都会接触一些局域网内的相关开发，比如某公司研发了一个app，该app需求是在局域网和网域网都可以获取自己好友的消息或信息，网域网下技术人员可以通过服务器转接信息和发送，实现交互，但是在非联网的局域网下使用部分非使用网络的功能，这就需要研究一些比较不常用的类，在通常情况下，可能大部分人首先想到的肯定是0-255的逐个去ping，这样效率超级低！而且粗暴的方式还可能导致oom，之前说到的 ping ，就是比如局域网下发射信号的主机即服务器，这里我就形象的说是路由器吧，比如路由器的ip是192.168.0.1，那连接它的其他设备的ip被分配的ip也是192.168.0.xxx，这里的xxx是一个取值范围0-255，很多时候大家为了方便就采用循环来对0-255这样的一个一个的去ping，也就是像192.168.0.2、192.168.0.3……这样一直到255,效率非常慢。。。 所以今天就给大家分享一个好东西，java.net.MulticastSocket MulticastSocket 继承自 DatagramSocket [java] view plain copy/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.*/ package java.net; import java.io.IOException;import java.util.Enumeration;import libcore.io.IoUtils; /** This class implements a multicast socket for sending and receiving IP multicast datagram packets. @see DatagramSocket*/public class MulticastSocket extends DatagramSocket { /** Stores the address supplied to setInterface so we can return it from getInterface. The translation to an interface index is lossy because an interface can have multiple addresses.*/private InetAddress setAddress; /** Constructs a multicast socket, bound to any available port on the local host. @throws IOException if an error occurs.*/public MulticastSocket() throws IOException { setReuseAddress(true);} /** Constructs a multicast socket, bound to the specified {@code port} on the local host. @throws IOException if an error occurs.*/public MulticastSocket(int port) throws IOException { super(port); setReuseAddress(true);} /** Constructs a {@code MulticastSocket} bound to the address and port specified by {@code localAddress}, or an unbound {@code MulticastSocket} if {@code localAddress == null}. @throws IllegalArgumentException if {@code localAddress} is not supported (because it’s not an {@code InetSocketAddress}, say). @throws IOException if an error occurs.*/public MulticastSocket(SocketAddress localAddress) throws IOException { super(localAddress); setReuseAddress(true);} /** Returns an address of the outgoing network interface used by this socket. To avoid inherent unpredictability, new code should use {@link #getNetworkInterface} instead. @throws SocketException if an error occurs.*/public InetAddress getInterface() throws SocketException { checkOpen(); if (setAddress != null) { return setAddress; } InetAddress ipvXaddress = (InetAddress) impl.getOption(SocketOptions.IP_MULTICAST_IF); if (ipvXaddress.isAnyLocalAddress()) { // the address was not set at the IPv4 level so check the IPv6 // level NetworkInterface theInterface = getNetworkInterface(); if (theInterface != null) { Enumeration&lt;InetAddress&gt; addresses = theInterface.getInetAddresses(); if (addresses != null) { while (addresses.hasMoreElements()) { InetAddress nextAddress = addresses.nextElement(); if (nextAddress instanceof Inet6Address) { return nextAddress; } } } } } return ipvXaddress;} /** Returns the outgoing network interface used by this socket. @throws SocketException if an error occurs.*/public NetworkInterface getNetworkInterface() throws SocketException { checkOpen(); int index = (Integer) impl.getOption(SocketOptions.IP_MULTICAST_IF2); if (index != 0) { return NetworkInterface.getByIndex(index); } return NetworkInterface.forUnboundMulticastSocket();} /** Returns the time-to-live (TTL) for multicast packets sent on this socket. @throws IOException if an error occurs.*/public int getTimeToLive() throws IOException { checkOpen(); return impl.getTimeToLive();} /** Returns the time-to-live (TTL) for multicast packets sent on this socket. @throws IOException if an error occurs. @deprecated Use {@link #getTimeToLive} instead.*/@Deprecatedpublic byte getTTL() throws IOException { checkOpen(); return impl.getTTL();} /** Adds this socket to the specified multicast group. A socket must join a group before data may be received. A socket may be a member of multiple groups but may join any group only once. @param groupAddr the multicast group to be joined. @throws IOException if an error occurs.*/public void joinGroup(InetAddress groupAddr) throws IOException { checkJoinOrLeave(groupAddr); impl.join(groupAddr);} /** Adds this socket to the specified multicast group. A socket must join a group before data may be received. A socket may be a member of multiple groups but may join any group only once. @param groupAddress the multicast group to be joined. @param netInterface the network interface on which the datagram packets will be received. @throws IOException if the specified address is not a multicast address. @throws IllegalArgumentException if no multicast group is specified.*/public void joinGroup(SocketAddress groupAddress, NetworkInterface netInterface) throws IOException {checkJoinOrLeave(groupAddress, netInterface);impl.joinGroup(groupAddress, netInterface);} /** Removes this socket from the specified multicast group. @param groupAddr the multicast group to be left. @throws NullPointerException if {@code groupAddr} is {@code null}. @throws IOException if the specified group address is not a multicast address.*/public void leaveGroup(InetAddress groupAddr) throws IOException {checkJoinOrLeave(groupAddr);impl.leave(groupAddr);} /** Removes this socket from the specified multicast group. @param groupAddress the multicast group to be left. @param netInterface the network interface on which the addresses should be dropped. @throws IOException if the specified group address is not a multicast address. @throws IllegalArgumentException if {@code groupAddress} is {@code null}.*/public void leaveGroup(SocketAddress groupAddress, NetworkInterface netInterface) throws IOException {checkJoinOrLeave(groupAddress, netInterface);impl.leaveGroup(groupAddress, netInterface);} private void checkJoinOrLeave(SocketAddress groupAddress, NetworkInterface netInterface) throws IOException {checkOpen();if (groupAddress == null) {throw new IllegalArgumentException(“groupAddress == null”);} if (netInterface != null &amp;&amp; !netInterface.getInetAddresses().hasMoreElements()) {throw new SocketException(“No address associated with interface: “ + netInterface);} if (!(groupAddress instanceof InetSocketAddress)) {throw new IllegalArgumentException(“Group address not an InetSocketAddress: “ +groupAddress.getClass());} InetAddress groupAddr = ((InetSocketAddress) groupAddress).getAddress();if (groupAddr == null) {throw new SocketException(“Group address has no address: “ + groupAddress);} if (!groupAddr.isMulticastAddress()) {throw new IOException(“Not a multicast group: “ + groupAddr);}} private void checkJoinOrLeave(InetAddress groupAddr) throws IOException {checkOpen();if (groupAddr == null) {throw new IllegalArgumentException(“groupAddress == null”);}if (!groupAddr.isMulticastAddress()) {throw new IOException(“Not a multicast group: “ + groupAddr);}} /** Sends the given {@code packet} on this socket, using the given {@code ttl}. This method is deprecated because it modifies the TTL socket option for this socket twice on each call. @throws IOException if an error occurs. @deprecated Use {@link #setTimeToLive} instead.*/@Deprecatedpublic void send(DatagramPacket packet, byte ttl) throws IOException { checkOpen(); InetAddress packAddr = packet.getAddress(); int currTTL = getTimeToLive(); if (packAddr.isMulticastAddress() &amp;&amp; (byte) currTTL != ttl) { try { setTimeToLive(ttl &amp; 0xff); impl.send(packet); } finally { setTimeToLive(currTTL); } } else { impl.send(packet); }} /** Sets the outgoing network interface used by this socket. The interface used is the first interface found to have the given {@code address}. To avoid inherent unpredictability, new code should use {@link #getNetworkInterface} instead. @throws SocketException if an error occurs.*/public void setInterface(InetAddress address) throws SocketException { checkOpen(); if (address == null) { throw new NullPointerException(&quot;address == null&quot;); } NetworkInterface networkInterface = NetworkInterface.getByInetAddress(address); if (networkInterface == null) { throw new SocketException(&quot;Address not associated with an interface: &quot; + address); } impl.setOption(SocketOptions.IP_MULTICAST_IF2, networkInterface.getIndex()); this.setAddress = address;} /** Sets the outgoing network interface used by this socket to the given {@code networkInterface}. @throws SocketException if an error occurs.*/public void setNetworkInterface(NetworkInterface networkInterface) throws SocketException { checkOpen(); if (networkInterface == null) { throw new SocketException(&quot;networkInterface == null&quot;); } impl.setOption(SocketOptions.IP_MULTICAST_IF2, networkInterface.getIndex()); this.setAddress = null;} /** Sets the time-to-live (TTL) for multicast packets sent on this socket. Valid TTL values are between 0 and 255 inclusive. @throws IOException if an error occurs.*/public void setTimeToLive(int ttl) throws IOException { checkOpen(); if (ttl &lt; 0 || ttl &gt; 255) { throw new IllegalArgumentException(&quot;TimeToLive out of bounds: &quot; + ttl); } impl.setTimeToLive(ttl);} /** Sets the time-to-live (TTL) for multicast packets sent on this socket. Valid TTL values are between 0 and 255 inclusive. @throws IOException if an error occurs. @deprecated Use {@link #setTimeToLive} instead.*/@Deprecatedpublic void setTTL(byte ttl) throws IOException { checkOpen(); impl.setTTL(ttl);} @Overridesynchronized void createSocket(int aPort, InetAddress addr) throws SocketException { impl = factory != null ? factory.createDatagramSocketImpl() : new PlainDatagramSocketImpl(); impl.create(); try { impl.setOption(SocketOptions.SO_REUSEADDR, Boolean.TRUE); impl.bind(aPort, addr); isBound = true; } catch (SocketException e) { close(); throw e; }} /** Returns true if multicast loopback is disabled. See {@link SocketOptions#IP_MULTICAST_LOOP}, and note that the sense of this is the opposite of the underlying Unix {@code IP_MULTICAST_LOOP}. @throws SocketException if an error occurs.*/public boolean getLoopbackMode() throws SocketException { checkOpen(); return !((Boolean) impl.getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();} /** Disables multicast loopback if {@code disable == true}. See {@link SocketOptions#IP_MULTICAST_LOOP}, and note that the sense of this is the opposite of the underlying Unix {@code IP_MULTICAST_LOOP}: true means disabled, false means enabled. @throws SocketException if an error occurs.*/public void setLoopbackMode(boolean disable) throws SocketException { checkOpen(); impl.setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(!disable));}} 了解一下该类后可以开始下面的编程，首先说一下客户端，再说服务端，最后说明使用方法①客户端代码核心： [java] view plain copy@Overrideprotected void onResume() { super.onResume(); /** * @author Engineer-Jsp * 笔者在该 Activity 的 onResume()函数初始化接收的侦听 */ onBrodacastReceiver(); }②onBrodacastReceiver()函数：[java] view plain copyMulticastSocket multicastSocket; /** @author Engineer-Jsp onBrodacastReceiver()*/private void onBrodacastReceiver() { new Thread(new Runnable() { @Override public void run() { try { // 接收数据时需要指定监听的端口号 multicastSocket = new MulticastSocket(10001); // 创建组播ID地址 InetAddress address = InetAddress.getByName(&quot;239.0.0.1&quot;); // 加入地址 multicastSocket.joinGroup(address); // 包长 byte[] buf = new byte[1024]; while (true) { // 数据报 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 接收数据，同样会进入阻塞状态 multicastSocket.receive(datagramPacket); // 从buffer中截取收到的数据 byte[] message = new byte[datagramPacket.getLength()]; // 数组拷贝 System.arraycopy(buf, 0, message, 0, datagramPacket.getLength()); // 打印来自组播里其他服务的or客户端的ip System.out.println(datagramPacket.getAddress()); // 打印来自组播里其他服务的or客户端的消息 System.out.println(new String(message)); // 收到消息后可以进行记录然后二次确认，如果只是想获取ip，在发送方收到该消息后可关闭套接字，从而释放资源 onBrodacastSend(datagramPacket.getAddress()); } } catch (IOException e) { e.printStackTrace(); } } }).start();} ③ onBrodacastSend() 函数[java] view plain copy/** onBrodacastSend() @author Engineer-Jsp @param address ip*/private void onBrodacastSend(InetAddress address) { // 假设 239.0.0.1 已经收到了来自其他组ip段的消息，为了进行二次确认，发送 “snoop” // 进行确认，当发送方收到该消息可以释放资源 String out = “snoop”; // 获取”snoop”的字节数组 byte[] buf = out.getBytes(); // 组报 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 设置地址，该地址来自onBrodacastReceiver()函数阻塞数据报，datagramPacket.getAddress() datagramPacket.setAddress(address); // 发送的端口号 datagramPacket.setPort(8082); try { // 开始发送 multicastSocket.send(datagramPacket); } catch (IOException e) { e.printStackTrace(); }} 这是客户端的代码，下面开始上服务端的代码①初始化 [java] view plain copy@Overrideprotected void onResume() { super.onResume(); /** * @author Engineer-Jsp * 笔者在该 Activity 的 onResume()函数初始化接收和发送 * onBrodacastSend() 发送 * onBrodacastReceiver() 接收 */ onBrodacastSend(); onBrodacastReceiver(); }② onBrodacastSend() 函数[java] view plain copyInetAddress address;MulticastSocket multicastSocket; /** @author Engineer-Jsp onBrodacastSend() 发送*/private void onBrodacastSend() { try { // 侦听的端口 multicastSocket = new MulticastSocket(8082); // 使用D类地址，该地址为发起组播的那个ip段，即侦听10001的套接字 address = InetAddress.getByName(&quot;239.0.0.1&quot;); new Thread(new Runnable() { @Override public void run() { while (true) { // 获取当前时间 String time = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()); // 当前时间+标识后缀 time = time + &quot; &gt;&gt;&gt; form server onBrodacastSend()&quot;; // 获取当前时间+标识后缀的字节数组 byte[] buf = time.getBytes(); // 组报 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 向组播ID，即接收group /239.0.0.1 端口 10001 datagramPacket.setAddress(address); // 发送的端口号 datagramPacket.setPort(10001); try { // 开始发送 multicastSocket.send(datagramPacket); // 每执行一次，线程休眠2s，然后继续下一次任务 Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } }).start(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }} ③onBrodacastReceiver(）函数[java] view plain copy/** @author Engineer-Jsp onBrodacastReceiver() 接收*/private void onBrodacastReceiver() { new Thread(new Runnable() { @Override public void run() { try { // 字节数组的格式，即最大大小 byte[] buf = new byte[1024]; while (true) { // 组报格式 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 接收来自group组播10001端口的二次确认，阻塞 multicastSocket.receive(datagramPacket); // 从buf中截取收到的数据 byte[] message = new byte[datagramPacket.getLength()]; // 数组拷贝 System.arraycopy(buf, 0, message, 0, datagramPacket.getLength()); // 这里打印ip字段 System.out.println(datagramPacket.getAddress()); // 打印组播端口10001发送过来的消息 System.out.println(new String(message)); // 这里可以根据结接收到的内容进行分发处理，假如收到 10001的 &quot;snoop&quot;字段为关闭命令，即可在此处关闭套接字从而释放资源 } } catch (IOException e) { e.printStackTrace(); } } }).start();} 这是服务端的代码，也分享完了，下面画一个图来大概描述一下他们的工作流程图示意： 使用方法：①首先需要在同一wifi网络下 ②需要获取所有ip的手机安装客户端，即侦听10001的那个端口 ③所有需要将信息共享并组播到 239.0.0.1:10001这个group的安装服务端 ④开启服务端与客户端开始进行数据的交互 以上是大致的描述图，帮助大家理解，谢谢观博！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MulticastSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基本技术点无线设备]]></title>
    <url>%2F2018%2F05%2F24%2FAndroid%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%82%B9%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[无线连接设备 Network Service Discovery:NSD网络服务发现。 WiFi建立P2P连接 使用WiFi P2P服务 NSD网络发现 NsdManager 管理涉及到服务注册、监听器、取消服务等，当业务完成要及时取消注册服务(取消注册、关闭搜索服务)，防止占用资源 registerService注册监听器 resolveService解析监听器 discoverServices搜索可发现服务 NsdServiceInfo注册服务的信息 - setServiceName - setPort - setServiceType 不推荐硬编码设置端口号，建议使用这种： ServerSocket sock = new ServerSocket(0); port = sock.getLocalPort(); sock.close(); 其中的服务类型写法：指定应用使用的协议和传输层。语法是“_&lt; protocol &gt;._&lt; transportlayer &gt;” NsdManager.DiscoveryListener mDiscoveryListener = new NsdManager.DiscoveryListener() { // Called as soon as service discovery begins. @Override public void onDiscoveryStarted(String regType) { Log.d(TAG, &quot;Service discovery started&quot;); } @Override public void onServiceFound(NsdServiceInfo service) { // A service was found! Do something with it. Log.d(TAG, &quot;Service discovery success&quot; + service); if (!service.getServiceType().equals(&quot;_http._tcp.&quot;)) { // Service type is the string containing the protocol and // transport layer for this service. Log.d(TAG, &quot;Unknown Service Type: &quot; + service.getServiceType()); } else if (service.getServiceName().equals(mServiceName)) { // The name of the service tells the user what they&apos;d be // connecting to. It could be &quot;Bob&apos;s Chat App&quot;. Log.d(TAG, &quot;Same machine: &quot; + mServiceName); } else if (service.getServiceName().contains(&quot;NsdChat&quot;)){ mNsdManager.resolveService(service, mResolveListener); } } @Override public void onServiceLost(NsdServiceInfo service) { // When the network service is no longer available. // Internal bookkeeping code goes here. Log.e(TAG, &quot;service lost&quot; + service); } @Override public void onDiscoveryStopped(String serviceType) { Log.i(TAG, &quot;Discovery stopped: &quot; + serviceType); } @Override public void onStartDiscoveryFailed(String serviceType, int errorCode) { Log.e(TAG, &quot;Discovery failed: Error code:&quot; + errorCode); mNsdManager.stopServiceDiscovery(this); } @Override public void onStopDiscoveryFailed(String serviceType, int errorCode) { Log.e(TAG, &quot;Discovery failed: Error code:&quot; + errorCode); mNsdManager.stopServiceDiscovery(this); } }; NsdManager.RegistrationListener mRegistrationListener = new NsdManager.RegistrationListener() { @Override public void onServiceRegistered(NsdServiceInfo NsdServiceInfo) { // Save the service name. Android may have changed it in order to // resolve a conflict, so update the name you initially requested // with the name Android actually used. mServiceName = NsdServiceInfo.getServiceName(); } @Override public void onRegistrationFailed(NsdServiceInfo serviceInfo, int errorCode) { // Registration failed! Put debugging code here to determine why. } @Override public void onServiceUnregistered(NsdServiceInfo arg0) { // Service has been unregistered. This only happens when you call // NsdManager.unregisterService() and pass in this listener. } @Override public void onUnregistrationFailed(NsdServiceInfo serviceInfo, int errorCode) { // Unregistration failed. Put debugging code here to determine why. } }; NsdManager.ResolveListener mResolveListener = new NsdManager.ResolveListener() { @Override public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) { // Called when the resolve fails. Use the error code to debug. Log.e(TAG, &quot;Resolve failed&quot; + errorCode); } @Override public void onServiceResolved(NsdServiceInfo serviceInfo) { Log.e(TAG, &quot;Resolve Succeeded. &quot; + serviceInfo); if (serviceInfo.getServiceName().equals(mServiceName)) { Log.d(TAG, &quot;Same IP.&quot;); return; } } }; 大致流程：注册本机服务 -&gt; 注册监听 -&gt; 注解解析 -&gt; 搜索发现服务 -&gt; 解析可发现的 -&gt; 获取ip 端口号 -&gt; 连接 WiFi p2p连接 p2p不需要访问网络，但是会使用java中的socket，socket需网络权限( CHANGE_WIFI_STATE、ACCESS_WIFI_STATE、INTERNET) 设置广播接收器和p2p管理器 首先注册广播，监听每次的wifi p2p事件变化，主要监听WIFI_P2P_STATE_CHANGED_ACTION Wi-Fi P2P 是否开启，WIFI_P2P_PEERS_CHANGED_ACTION 对等节点（peer）列表发生了变化,WIFI_P2P_CONNECTION_CHANGED_ACTION 连接状态发生了改变,WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 设备的详细配置发生了变化这些广播，这些广播定义在WifiP2pManager类中。 实例化Channel对象，在后续的方法中基本都需要用到，WifiP2pManager的方法基本都需要这个，应该是传递数据封装数据用的。 mChannel = mManager.initialize(this, getMainLooper(), null); 初始化对等节点发现（Peer Discovery） discoverPeers() 搜索设备 基本概念 WPS是啥？？？？： （Wi-Fi Protected Setup，Wi-Fi保护设置）（有的叫做AOSS、有的叫做QSS，不过功能都一致。）是由Wi-Fi联盟组织实施的认证项目，主要致力于简化无线局域网的安装及安全性能配置工作。在传统方式下，用户新建一个无线网络时，必须在接入点手动设置网络名（SSID）和安全密钥，然后在客户端验证密钥以阻止“不速之客”的闯入。这整个过程需要用户具备Wi-Fi设备的背景知识和修改必要配置的能力。Wi- Fi Protected Setup能帮助用户自动设置网络名（SSID）、配置强大的WPA数据编码及认证功能，用户只需输入个人信息码（PIN方法）或按下按钮（按钮设置，或称PBC），即能安全地连入WLAN。这大大简化了无线安全设置的操作。Wi-Fi Protected Setup支持多种通过Wi-Fi认证的802.11产品，包括接入点、无线适配器、Wi-Fi电话以及其他消费性电子设备。 WPS分为PBC(BUTTON)和PIN两种方式： A PBC: 按WPS按钮实现WPS安全连接. 在AP中，在WPS设置中,设置为启用. 按一下客户端(无线网卡)上的WPS按键,搜索WPS网络. 按一下AP上的WPS按键,WPS开始链接协商,片刻后WPS安全连接成功建立. B PIN B1) PIN(Internal Registra, 相对于AP而言)：通过在路由器中输入客户端PIN码来实现WPS安全连接. 在WPS设置中,把状态设置为启用. 打开客户端WPS设置软件,选择在路由器中输入PIN的方式连接,同时软件上还会显示客户端当前的PIN码. 打开路由器界面,在WPS模式里选择PIN模式,然后输入客户端的PIN码,点添加新设备,一会儿后,WPS安全连接成功建立. B2) PIN(External Registra, 相对于AP而言)：通过输入AP的PIN码实现WPS安全连接.在AP中，在WPS设置中,设置为启用. 记住AP的PIN码,然后打开客户端（无线网卡）WPS设置软件,选择以AP的PIN码来进行连接. 输入完PIN码后,点下一步,一会儿后,WPS安全连接成功建立. 代码 public class WifiP2PActivity extends AppCompatActivity { String TAG = &quot; WifiP2P&quot;; WifiP2pManager mWifiP2pManager; Channel mChannel; IntentFilter mIntentFilter; WifiP2PBReciver mReciver; List&lt;WifiP2pDevice&gt; peers = new ArrayList(); WifiP2pConfig mWifiP2pConfig; //获取设备列表 private WifiP2pManager.PeerListListener peerListListener = new WifiP2pManager.PeerListListener() { @Override public void onPeersAvailable(WifiP2pDeviceList peerList) { // 获取设备列表 peerList.getDeviceList(); Log.i(TAG,&quot;获取的对等节点列表：&quot;+peerList.toString()); peers.clear(); peers.addAll(peerList.getDeviceList()); // 连接 不应该在这写，这是动态变化的，应该手动选择时从保存的对等节点列表中获取信息，去连接 mWifiP2pConfig = new WifiP2pConfig(); mWifiP2pConfig.deviceAddress = peers.get(0).deviceAddress; mWifiP2pConfig.wps.setup = WpsInfo.PBC; mWifiP2pManager.connect(mChannel, mWifiP2pConfig, new WifiP2pManager.ActionListener() { @Override public void onSuccess() { Log.i(TAG,&quot;连接成功了&quot;); } @Override public void onFailure(int reason) { Log.i(TAG,&quot;连接失败了:&quot;+reason); } }); } }; WifiP2pManager.ConnectionInfoListener connectionInfoListener = new WifiP2pManager.ConnectionInfoListener() { @Override public void onConnectionInfoAvailable(WifiP2pInfo info) { // InetAddress from WifiP2pInfo struct. //当有多个设备同时试图连接到一台设备时（例如多人游戏或者聊天群），这一台设备将被指定为“群主”（group owner）。 String groupOwnerAddress = info.groupOwnerAddress.getHostAddress(); // After the group negotiation, we can determine the group owner. if (info.groupFormed &amp;&amp; info.isGroupOwner) { // Do whatever tasks are specific to the group owner. // One common case is creating a server thread and accepting // incoming connections. } else if (info.groupFormed) { // The other device acts as the client. In this case, // you&apos;ll want to create a client thread that connects to the group // owner. } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_wifi_p2_p); mIntentFilter = new IntentFilter(); //连接状态发生了改变 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION); // 指示设备的详细配置发生了变化 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION); //代表对等节点（peer）列表发生了变化 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION); // 指示 Wi-Fi P2P 是否开启 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION); mWifiP2pManager = (WifiP2pManager) getApplicationContext().getSystemService(WIFI_P2P_SERVICE); mChannel = mWifiP2pManager.initialize(this, getMainLooper(), new WifiP2pManager.ChannelListener() { @Override public void onChannelDisconnected() { Log.i(TAG,&quot;通道断开&quot;); } }); //搜索对等节点 peers mWifiP2pManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() { @Override public void onSuccess() { Log.i(TAG,&quot;搜索成功！&quot;); } @Override public void onFailure(int reason) { //WifiP2pManager 中的失败值 /*** Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the operation failed due to an internal error. */int ERROR = 0; /** * Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the operation failed because p2p is unsupported on the device. */int P2P_UNSUPPORTED = 1; /** * Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the operation failed because the framework is busy and * unable to service the request */int BUSY = 2; /** * Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the {@link #discoverServices} failed because no service * requests are added. Use {@link #addServiceRequest} to add a service * request. */int NO_SERVICE_REQUESTS = 3; Log.e(TAG,&quot;搜索失败！&quot;+reason); } }); } @Override protected void onResume() { super.onResume(); //注册接受wifi p2p 状态变化广播 mReciver = new WifiP2PBReciver(); getApplicationContext().registerReceiver(mReciver,mIntentFilter); } @Override protected void onPause() { super.onPause(); try{ unregisterReceiver(mReciver); }catch (Exception e){ } } class WifiP2PBReciver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) { // Determine if Wifi P2P mode is enabled or not, alert // the Activity. int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1); if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) { } else { } } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) { // The peer list has changed! We should probably do something about // that. //在此处获取设备列表变化后的数据 mWifiP2pManager.requestPeers(mChannel,peerListListener); } else if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) { // Connection state changed! We should probably do something about // that. NetworkInfo networkInfo = (NetworkInfo) intent .getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO); if (networkInfo.isConnected()) { // We are connected with the other device, request connection // info to find group owner IP mWifiP2pManager.requestConnectionInfo(mChannel, connectionInfoListener); } } else if (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION.equals(action)) { WifiP2pDevice device = (WifiP2pDevice) intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE); } } } } WiFi P2P 服务发现 首先在本地注册一个服务，服务注册是要将服务类型、服务信息封装到WifiP2pServiceInfo中，再通过WifiP2pManager将服务添加到本地，本地服务添加后注册监听DnsSdTxtRecordListener来实时监听record记录数据，注册DnsSdServiceResponseListener接收服务的实际描述和连接的信息，前者处理记录连接的服务信息用来跟后者做对应关系处理。前者给你一组对他的服务的描述信息，然后在后者进行匹配，将描述信息与实际的硬件信息做匹配，把处理过的数据给用户看。连接后创建服务请求 addServiceRequest()，最后调用 discoverServices() WifiP2pManager(添加服务到本地) wifiP2pManager = (WifiP2pManager) getApplicationContext().getSystemService(WIFI_P2P_SERVICE); WifiP2pServiceInfo (创建本地服务的参数配置信息) WifiP2pDnsSdServiceInfo.newInstance(&quot;instanceName&quot;,&quot;serviceType&quot;,map); serviceType与NSD中的服务类型相同; 服务信息是通过存放在map方式存入，他人连接能够获取到该数据;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>网络发现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的四种引用]]></title>
    <url>%2F2018%2F05%2F24%2Fva%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[强引用 StrongReference强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 ps：强引用其实也就是我们平时A a = new A()这个意思。 弱引用 WeakReference 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 软引用 SoftReference 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 虚引用 PhantomReference “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 ReferenceQueue queue = new ReferenceQueue (); PhantomReference pr = new PhantomReference (object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 场景使用软引用构建敏感数据的缓存 1 为什么需要使用软引用 首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。 2 如果使用软引用 SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。 看下面代码: MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。 随即，我们可以结束aReference对这个MyObject实例的强引用: aRef = null; 此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过: MyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。 3 使用ReferenceQueue清除失去了软引用对象的SoftReference 作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如: ReferenceQueue queue = new ReferenceQueue(); SoftReferenceref=new SoftReference(aMyObject, queue); 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。 在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为: SoftReference ref = null; while ((ref = (EmployeeRef) q.poll()) != null) { // 清除ref } 抄自—&gt;Java四种引用包括强引用，软引用，弱引用，虚引用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到的几个Android学习网站]]></title>
    <url>%2F2018%2F05%2F24%2F%E7%9A%84%E5%87%A0%E4%B8%AAAndroid%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Android Studio使用相关的资料 查看文档之类的 应用的基本概念 gradle学习资料 中文Android学习资料网站大全]]></content>
      <categories>
        <category>学习网站</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记03]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%2F</url>
    <content type="text"><![CDATA[git基本操作符 init git init [-q | --quiet] [--bare] [--template=&lt;template_directory&gt;] [--separate-git-dir &lt;git dir&gt;] [--shared[=&lt;permissions&gt;]] [directory] add git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--chmod=(+|-)x] [--] [&lt;pathspec&gt;…​] 新文件创建，添加到git版本索引库中，加到暂存区，add操作要在commit之前使用。git add -f选项添加被忽略的文件。 $ git add . # 将所有修改添加到暂存区 $ git add * # Ant风格添加修改 $ git add *Controller # 将以Controller结尾的文件的所有修改添加到暂存区 clone git clone [--template=&lt;template_directory&gt;] [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror] [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;] [--dissociate] [--separate-git-dir &lt;git dir&gt;] [--depth &lt;depth&gt;] [--[no-]single-branch] [--recurse-submodules] [--[no-]shallow-submodules] [--jobs &lt;n&gt;] [--] &lt;repository&gt; [&lt;directory&gt;] status git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​] tracked文件被监控文件，untracked文件为要被忽略的文件，不需要提交，在.gitignore文件中加入要忽略的文件通配符；通过git status -uno可以只列出所有已经被git管理的且被修改但没提交的文件 diff git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​] git diff [options] &lt;blob&gt; &lt;blob&gt; git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt; commit git commit [-a | –interactive | –patch] [-s] [-v] [-u] [–amend] [--dry-run] [(-c | -C | --fixup | --squash) &lt;commit&gt;] [-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author=&lt;author&gt;] [--date=&lt;date&gt;] [--cleanup=&lt;mode&gt;] [--[no-]status] [-i | -o] [-S[&lt;keyid&gt;]] [--] [&lt;file&gt;…​] $ git add . $ # 或者~ $ git add newfile.txt $ git commit -m &quot;the commit message&quot; # $ git commit -a # 会先把所有已经track的文件的改动`git add`进来，然后提交(有点像svn的一次提交,不用先暂存)。对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。 $ git commit --amend # 增补提交，会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>pull</tag>
        <tag>commit</tag>
        <tag>status</tag>
        <tag>init</tag>
        <tag>clone</tag>
        <tag>reset</tag>
        <tag>merge</tag>
        <tag>add</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记02]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%2F</url>
    <content type="text"><![CDATA[git的流程创建仓库 -&gt; 初始化仓库 -&gt; 初始化项目 -&gt; 个人拉取项目到本地 -&gt; 本地文件添加 -&gt; 本地文件修改 -&gt; 提交 -&gt; 差异合并 -&gt; 更新 -&gt; 合并 -&gt; 提交 -&gt; 推送 head代表的是分支]]></content>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记01]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[基础的知识点 基础 git保存所有的文件的快照的索引，而非对比数据的差异；操作大多数是在本地执行； 三种状态：已提交committed、已修改modified、已暂存staged 基本工作流程 本地工作目录修改文件 将文件快照存放在暂存区域 提交更新，找到暂存区快照，将快照永久存在git仓库目录 大致的流程 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 配置 配置文件git config配置git外观和行为的配置变量，在linux下有三个位置：/etc/gitconfig,~/.gitconfig 或 ~/.config/git/config,当前使用仓库的 Git 目录中的 config;在windows系统下：$HOME目录(C:\Users\$USER)的 .gitconfig),git安装目录下的gitconfig文件; 配置用户信息 $ git config --global user.name &quot;maxsu&quot; $ git config --global user.email maxsu@yiibai.com 文本编辑器 $ git config --global core.editor emacs 如果不习惯使用vim就使用该方法替换掉； 获取配置信息 git config --list]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree]]></title>
    <url>%2F2018%2F05%2F23%2FourceTree%2F</url>
    <content type="text"><![CDATA[git的图形化工具，只支持mac和windows 跳过账号登录在用户本地文件夹下的 SourceTree 目录下，找到accounts.json文件 没有就创建复制一下内容： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot;&quot;, &quot;Email&quot;: null }, &quot;IsDefault&quot;: false } ]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown编辑器]]></title>
    <url>%2F2018%2F05%2F22%2Fmarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[小书匠 下载地址能够将数据保存到github、云存贮等；]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[既然是程序员，第一个文章当然就是一个：HELLO WORLD!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android中的设计模式]]></title>
    <url>%2F2018%2F05%2F21%2FAndroid%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[（1）单例模式： 简介：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 示例：Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗。 比如LayoutInflater Service，将这些服务以键值对的形式存储在一个HashMap容器中，用户使用时只需要根据key来获取到对应的ServiceFetcher，然后通过ServcieFetcher对象的getService函数来获取到具体的服务对象，第一次获取时会调用ServcieFetcher的createService函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。（2）抽象工厂模式： 简介：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 示例：Android底层对MediaPlayer的创建。MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。（3）工厂模式： 简介：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。（4）原型模式： 简介：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 示例：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。（5）建造者模式： 简介：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 示例：AlertDialog.Builder ImageLoader的初始配置。（6）适配器模式： 简介：将一个类的接口转换成客户希望的另外一个接口。 示例：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。 ListView或GridView的Adapter。（7）桥接模式： 简介：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 示例：Window和WindowManager之间的关系。 在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。（8）装饰模式： 简介：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。（9）组合模式： 简介：将对象组合成树形结构以表示“部分-整体”的层次结构。 示例：View和ViewGroup的组合（10）外观模式 简介：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。 示例：ContextImpl（11）享元模式： 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。（12）代理模式： 简介：为其他对象提供一个代理以控制对这个对象的访问。 示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。（13）观察者模式： 简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。 示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。（14）中介者模式： 简介：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 示例：Binder机制。(15)访问者模式: 简介：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。（16） 解释器模式： 简介：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程，（17）迭代器模式 简介：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。（18）备忘录模式 简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。（19）责任链模式 简介：有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 示例: 责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。（20）状态模式： 简介：状态发生改变时，行为改变。 示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。（21）策略模式 简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。 示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。（22）命令模式 简介：把请求封装成一个对象发送出去，方便定制、排队、取消。 示例：Handler.post后Handler.handleMessage。（23）享元模式 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块模式设计]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[什么是设计模式 定义基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。 开闭原则：对修改封闭，对扩展放开。 里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。 接口隔离原则：将大接口改成多个小接口。 迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。 分类设计模式分为三种类型：创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。（口诀：单原建造者，东西二厂） 结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。（口诀：一器一桥一元一代理；装饰组合外观） 行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。（口诀：三者两器、一录一链一模板，状态策略命令） 功能模块设计原则 单一职责原则（Single Responsibility Principle - SRP）原文：There should never be more than one reason for a class to change. 译文：永远不应该有多于一个原因来改变某个类。 理解：对于一个类而言，应该仅有一个引起它变化的原因。说白了就是，不同的类具备不同的职责，各施其责。这就好比一个团队，大家分工协作，互不影响，各做各的事情。 应用：当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！ 开放封闭原则（Open Closed Principle - OCP）原文：Software entities like classes, modules and functions should be open for extension but closed for modifications. 译文：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。 理解：简言之，对扩展开放，对修改封闭。换句话说，可以去扩展类，但不要去修改类。 应用：当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。 里氏替换原则（Liskov Substitution Principle - LSP）原文：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 译文：使用基类的指针或引用的函数，必须是在不知情的情况下，能够使用派生类的对象。 理解：父类能够替换子类，但子类不一定能替换父类。也就是说，在代码中可以将父类全部替换为子类，程序不会报错，也不会在运行时出现任何异常，但反过来却不一定成立。 应用：在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），子类尽量不要暴露自己的 public 方法供外界调用。 最少知识原则（Least Knowledge Principle - LKP）原文：Only talk to you immediate friends. 译文：只与你最直接的朋友交流。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。 应用：在做系统设计时，不要让一个类依赖于太多的其他类，需尽量减小依赖关系，否则，您死都不知道自己怎么死的。 接口隔离原则（Interface Segregation Principle - ISP）原文：The dependency of one class to another one should depend on the smallest possible interface. 译文：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。、理解：不要对外暴露没有实际意义的接口。也就是说，接口是给别人调用的，那就不要去为难别人了，尽可能保证接口的实用性吧。她好，我也好。 应用：当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，就意味着，您将来要多做一件事情，何苦要给自己找事做呢。 依赖倒置原则（Dependence Inversion Principle - DIP）原文：High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 译文：高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 理解：应该面向接口编程，不应该面向实现类编程。面向实现类编程，相当于就是论事，那是正向依赖（正常人思维）；面向接口编程，相当于通过事物表象来看本质，那是反向依赖，即依赖倒置（程序员思维）。 应用：并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧。 ------&gt;------&gt;------&gt;------&gt;------&gt;------&gt;------&gt; 将以上六大原则的英文首字母拼在一起就是 SOLID（稳定的），所以也称之为 SOLID 原则。只有满足了这六大原则，才能设计出稳定的软件架构！但它们毕竟只是原则，只是四人帮给我们的建议，有些时候我们还是要学会灵活应变，千万不要生搬硬套，否则只会把简单问题复杂化 补充设计原则 组合/聚合复用原则（Composition/Aggregation Reuse Principle - CARP）当要扩展类的功能时，优先考虑使用组合，而不是继承。这条原则在 23 种经典设计模式中频繁使用，如：代理模式、装饰模式、适配器模式等。可见江湖地位非常之高！ 无环依赖原则（Acyclic Dependencies Principle - ADP）当 A 模块依赖于 B 模块，B 模块依赖于 C 模块，C 依赖于 A 模块，此时将出现循环依赖。在设计中应该避免这个问题，可通过引入“中介者模式”解决该问题。 共同封装原则（Common Closure Principle - CCP）应该将易变的类放在同一个包里，将变化隔离出来。该原则是“开放-封闭原则”的延生。 共同重用原则（Common Reuse Principle - CRP）如果重用了包中的一个类，那么也就相当于重用了包中的所有类，我们要尽可能减小包的大小。 好莱坞原则（Hollywood Principle - HP）好莱坞明星的经纪人一般都很忙，他们不想被打扰，往往会说：Don&apos;t call me, I&apos;ll call you. 翻译为：不要联系我，我会联系你。对应于软件设计而言，最著名的就是“控制反转”（或称为“依赖注入”），我们不需要在代码中主动的创建对象，而是由容器帮我们来创建并管理这些对象。 其它设计原则 不要重复你自己（Don’t repeat yourself - DRY）不要让重复的代码到处都是，要让它们足够的重用，所以要尽可能地封装。 保持它简单与傻瓜（Keep it simple and stupid - KISS）不要让系统变得复杂，界面简洁，功能实用，操作方便，要让它足够的简单，足够的傻瓜。 高内聚与低耦合（High Cohesion and Low Coupling - HCLC）模块内部需要做到内聚度高，模块之间需要做到耦合度低。 惯例优于配置（Convention over Configuration - COC）尽量让惯例来减少配置，这样才能提高开发效率，尽量做到“零配置”。很多开发框架都是这样做的。 命令查询分离（Command Query Separation - CQS）在定义接口时，要做到哪些是命令，哪些是查询，要将它们分离，而不要揉到一起。 关注点分离（Separation of Concerns - SOC）将一个复杂的问题分离为多个简单的问题，然后逐个解决这些简单的问题，那么这个复杂的问题就解决了。难就难在如何进行分离。 契约式设计（Design by Contract - DBC）模块或系统之间的交互，都是基于契约（接口或抽象）的，而不要依赖于具体实现。该原则建议我们要面向契约编程。 你不需要它（You aren’t gonna need it - YAGNI）不要一开始就把系统设计得非常复杂，不要陷入“过度设计”的深渊。应该让系统足够的简单，而却又不失扩展性，这是其中的难点。]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F05%2F21%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射实现方式 实例化要反射的Class对象Class.forName(类名全路径); //通过Class的静态方法；对象.getClass() //通过对象.getClass方法；int.class //基本数据类型及基本数据类型的封装了，例如Integer； 获取父类Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Class&lt;?&gt; superclass = clazz.getSuperclass(); 获取实现接口Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Class&lt;?&gt;[] interfaces = clazz.getInterfaces() 获取指定参数构造函数及实例化Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Constructor&lt;?&gt; constructor = clazz.getConstructor(Class&lt;?&gt; ... class);//获取公共的 Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor()//获取私有的 constructor.newInstance(Object args); 获取所有构造函数及构造参数的类型Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors();//公共的 Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors()//包括私有的 for (int i = 0; i &lt; constructors.length; i++) { Class&lt;?&gt; clazzs[] = constructors[i].getParameterTypes();//获取类型 System.out.print(&quot;constructors[&quot; + i + &quot;] (&quot;); for (int j = 0; j &lt; clazzs.length; j++) { if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + &quot;,&quot;); } System.out.println(&quot;)&quot;); } 通过无参实例化对象Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 class.newInstance(); 获取字段，修改字段Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Field field = clazz.getField(String name);//获取公共字段 Field field = clazz.getDeclaredField(String name);//获取私有公共字段 Field[] field = clazz.getFields();//获取所有公共字段 Field[] field = clazz.getDeclaredFields();//获取包括私有所有字段 Field field = clazz.getDeclaredField(&quot;heihei&quot;); field.setAccessible(true);//设置java取消访问检查，也就是说如果是私有的也可以访问, field.set(obj, &quot;Java反射机制&quot;); 获取方法,运行方法Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 clazz.getMethod(String name ,Class&lt;?&gt; ... parame);//获取公共指定方法 clazz.getDeclaredMethod(String name ,Class&lt;?&gt; ... parame)//获取私有指定方法 clazz.getMethods()//获取公共所有方法 clazz.getDeclaredMethods();//获取包括私有全部方法 Method method = clazz.getMethod(&quot;add&quot;); method.invoke(clazz.newInstance()); method = clazz.getMethod(&quot;getInfo&quot;, int.class, String.class); method.setAccessible(true)//设置java取消访问检查，也就是说如果是私有的也可以访问, method.invoke(clazz.newInstance(), 20, &quot;张三&quot;); 获取数组或者list中的类型,如果不是数组或集合返回nullClass&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Class&lt;?&gt; componentType = clazz.getComponentType();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妞妞照片]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%A6%9E%E5%A6%9E%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>照片</category>
      </categories>
      <tags>
        <tag>妞妞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的妞妞]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%88%91%E7%9A%84%E5%A6%9E%E5%A6%9E%2F</url>
    <content type="text"><![CDATA[我的妞妞长的好看！！！美！！！]]></content>
      <tags>
        <tag>妞妞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜园子博客开始的地方]]></title>
    <url>%2F2018%2F05%2F21%2Fpost%2F</url>
    <content type="text"><![CDATA[打今天开始打理自己菜园子，菜园子有三块地，笔记、生活照片、记事本没啥说的，希望能够坚持下去，早点给自己定个目标吧。]]></content>
      <tags>
        <tag>给自己</tag>
      </tags>
  </entry>
</search>
