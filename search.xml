<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git学习笔记03]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%2F</url>
    <content type="text"><![CDATA[git基本操作符 init git init [-q | --quiet] [--bare] [--template=&lt;template_directory&gt;] [--separate-git-dir &lt;git dir&gt;] [--shared[=&lt;permissions&gt;]] [directory] add git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--chmod=(+|-)x] [--] [&lt;pathspec&gt;…​] 新文件创建，添加到git版本索引库中，加到暂存区，add操作要在commit之前使用。git add -f选项添加被忽略的文件。 $ git add . # 将所有修改添加到暂存区 $ git add * # Ant风格添加修改 $ git add *Controller # 将以Controller结尾的文件的所有修改添加到暂存区 clone git clone [--template=&lt;template_directory&gt;] [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror] [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;] [--dissociate] [--separate-git-dir &lt;git dir&gt;] [--depth &lt;depth&gt;] [--[no-]single-branch] [--recurse-submodules] [--[no-]shallow-submodules] [--jobs &lt;n&gt;] [--] &lt;repository&gt; [&lt;directory&gt;] status git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​] tracked文件被监控文件，untracked文件为要被忽略的文件，不需要提交，在.gitignore文件中加入要忽略的文件通配符；通过git status -uno可以只列出所有已经被git管理的且被修改但没提交的文件 diff git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​] git diff [options] &lt;blob&gt; &lt;blob&gt; git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt; commit git commit [-a | –interactive | –patch] [-s] [-v] [-u] [–amend] [--dry-run] [(-c | -C | --fixup | --squash) &lt;commit&gt;] [-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author=&lt;author&gt;] [--date=&lt;date&gt;] [--cleanup=&lt;mode&gt;] [--[no-]status] [-i | -o] [-S[&lt;keyid&gt;]] [--] [&lt;file&gt;…​] $ git add . $ # 或者~ $ git add newfile.txt $ git commit -m &quot;the commit message&quot; # $ git commit -a # 会先把所有已经track的文件的改动`git add`进来，然后提交(有点像svn的一次提交,不用先暂存)。对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。 $ git commit --amend # 增补提交，会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>pull</tag>
        <tag>commit</tag>
        <tag>status</tag>
        <tag>init</tag>
        <tag>clone</tag>
        <tag>reset</tag>
        <tag>merge</tag>
        <tag>add</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记02]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%2F</url>
    <content type="text"><![CDATA[git的流程创建仓库 -&gt; 初始化仓库 -&gt; 初始化项目 -&gt; 个人拉取项目到本地 -&gt; 本地文件添加 -&gt; 本地文件修改 -&gt; 提交 -&gt; 差异合并 -&gt; 更新 -&gt; 合并 -&gt; 提交 -&gt; 推送]]></content>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记01]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[基础的知识点 基础 git保存所有的文件的快照的索引，而非对比数据的差异；操作大多数是在本地执行； 三种状态：已提交committed、已修改modified、已暂存staged 基本工作流程 本地工作目录修改文件 将文件快照存放在暂存区域 提交更新，找到暂存区快照，将快照永久存在git仓库目录 大致的流程 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 配置 配置文件git config配置git外观和行为的配置变量，在linux下有三个位置：/etc/gitconfig,~/.gitconfig 或 ~/.config/git/config,当前使用仓库的 Git 目录中的 config;在windows系统下：$HOME目录(C:\Users\$USER)的 .gitconfig),git安装目录下的gitconfig文件; 配置用户信息 $ git config --global user.name &quot;maxsu&quot; $ git config --global user.email maxsu@yiibai.com 文本编辑器 $ git config --global core.editor emacs 如果不习惯使用vim就使用该方法替换掉； 获取配置信息 git config --list]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree]]></title>
    <url>%2F2018%2F05%2F23%2FourceTree%2F</url>
    <content type="text"><![CDATA[git的图形化工具，只支持mac和windows 跳过账号登录在用户本地文件夹下的 SourceTree 目录下，找到accounts.json文件 没有就创建复制一下内容： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot;&quot;, &quot;Email&quot;: null }, &quot;IsDefault&quot;: false } ]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown编辑器]]></title>
    <url>%2F2018%2F05%2F22%2Fmarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[小书匠 下载地址能够将数据保存到github、云存贮等；]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[既然是程序员，第一个文章当然就是一个：HELLO WORLD!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android中的设计模式]]></title>
    <url>%2F2018%2F05%2F21%2FAndroid%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[（1）单例模式： 简介：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 示例：Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗。 比如LayoutInflater Service，将这些服务以键值对的形式存储在一个HashMap容器中，用户使用时只需要根据key来获取到对应的ServiceFetcher，然后通过ServcieFetcher对象的getService函数来获取到具体的服务对象，第一次获取时会调用ServcieFetcher的createService函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。（2）抽象工厂模式： 简介：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 示例：Android底层对MediaPlayer的创建。MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。（3）工厂模式： 简介：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。（4）原型模式： 简介：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 示例：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。（5）建造者模式： 简介：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 示例：AlertDialog.Builder ImageLoader的初始配置。（6）适配器模式： 简介：将一个类的接口转换成客户希望的另外一个接口。 示例：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。 ListView或GridView的Adapter。（7）桥接模式： 简介：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 示例：Window和WindowManager之间的关系。 在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。（8）装饰模式： 简介：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。（9）组合模式： 简介：将对象组合成树形结构以表示“部分-整体”的层次结构。 示例：View和ViewGroup的组合（10）外观模式 简介：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。 示例：ContextImpl（11）享元模式： 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。（12）代理模式： 简介：为其他对象提供一个代理以控制对这个对象的访问。 示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。（13）观察者模式： 简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。 示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。（14）中介者模式： 简介：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 示例：Binder机制。(15)访问者模式: 简介：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。（16） 解释器模式： 简介：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程，（17）迭代器模式 简介：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。（18）备忘录模式 简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。（19）责任链模式 简介：有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 示例: 责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。（20）状态模式： 简介：状态发生改变时，行为改变。 示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。（21）策略模式 简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。 示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。（22）命令模式 简介：把请求封装成一个对象发送出去，方便定制、排队、取消。 示例：Handler.post后Handler.handleMessage。（23）享元模式 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块模式设计]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[什么是设计模式 定义基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。 开闭原则：对修改封闭，对扩展放开。 里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。 接口隔离原则：将大接口改成多个小接口。 迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。 分类设计模式分为三种类型：创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。（口诀：单原建造者，东西二厂） 结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。（口诀：一器一桥一元一代理；装饰组合外观） 行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。（口诀：三者两器、一录一链一模板，状态策略命令） 功能模块设计原则 单一职责原则（Single Responsibility Principle - SRP）原文：There should never be more than one reason for a class to change. 译文：永远不应该有多于一个原因来改变某个类。 理解：对于一个类而言，应该仅有一个引起它变化的原因。说白了就是，不同的类具备不同的职责，各施其责。这就好比一个团队，大家分工协作，互不影响，各做各的事情。 应用：当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！ 开放封闭原则（Open Closed Principle - OCP）原文：Software entities like classes, modules and functions should be open for extension but closed for modifications. 译文：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。 理解：简言之，对扩展开放，对修改封闭。换句话说，可以去扩展类，但不要去修改类。 应用：当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。 里氏替换原则（Liskov Substitution Principle - LSP）原文：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 译文：使用基类的指针或引用的函数，必须是在不知情的情况下，能够使用派生类的对象。 理解：父类能够替换子类，但子类不一定能替换父类。也就是说，在代码中可以将父类全部替换为子类，程序不会报错，也不会在运行时出现任何异常，但反过来却不一定成立。 应用：在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），子类尽量不要暴露自己的 public 方法供外界调用。 最少知识原则（Least Knowledge Principle - LKP）原文：Only talk to you immediate friends. 译文：只与你最直接的朋友交流。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。 应用：在做系统设计时，不要让一个类依赖于太多的其他类，需尽量减小依赖关系，否则，您死都不知道自己怎么死的。 接口隔离原则（Interface Segregation Principle - ISP）原文：The dependency of one class to another one should depend on the smallest possible interface. 译文：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。、理解：不要对外暴露没有实际意义的接口。也就是说，接口是给别人调用的，那就不要去为难别人了，尽可能保证接口的实用性吧。她好，我也好。 应用：当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，就意味着，您将来要多做一件事情，何苦要给自己找事做呢。 依赖倒置原则（Dependence Inversion Principle - DIP）原文：High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 译文：高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 理解：应该面向接口编程，不应该面向实现类编程。面向实现类编程，相当于就是论事，那是正向依赖（正常人思维）；面向接口编程，相当于通过事物表象来看本质，那是反向依赖，即依赖倒置（程序员思维）。 应用：并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧。 ------&gt;------&gt;------&gt;------&gt;------&gt;------&gt;------&gt; 将以上六大原则的英文首字母拼在一起就是 SOLID（稳定的），所以也称之为 SOLID 原则。只有满足了这六大原则，才能设计出稳定的软件架构！但它们毕竟只是原则，只是四人帮给我们的建议，有些时候我们还是要学会灵活应变，千万不要生搬硬套，否则只会把简单问题复杂化 补充设计原则 组合/聚合复用原则（Composition/Aggregation Reuse Principle - CARP）当要扩展类的功能时，优先考虑使用组合，而不是继承。这条原则在 23 种经典设计模式中频繁使用，如：代理模式、装饰模式、适配器模式等。可见江湖地位非常之高！ 无环依赖原则（Acyclic Dependencies Principle - ADP）当 A 模块依赖于 B 模块，B 模块依赖于 C 模块，C 依赖于 A 模块，此时将出现循环依赖。在设计中应该避免这个问题，可通过引入“中介者模式”解决该问题。 共同封装原则（Common Closure Principle - CCP）应该将易变的类放在同一个包里，将变化隔离出来。该原则是“开放-封闭原则”的延生。 共同重用原则（Common Reuse Principle - CRP）如果重用了包中的一个类，那么也就相当于重用了包中的所有类，我们要尽可能减小包的大小。 好莱坞原则（Hollywood Principle - HP）好莱坞明星的经纪人一般都很忙，他们不想被打扰，往往会说：Don&apos;t call me, I&apos;ll call you. 翻译为：不要联系我，我会联系你。对应于软件设计而言，最著名的就是“控制反转”（或称为“依赖注入”），我们不需要在代码中主动的创建对象，而是由容器帮我们来创建并管理这些对象。 其它设计原则 不要重复你自己（Don’t repeat yourself - DRY）不要让重复的代码到处都是，要让它们足够的重用，所以要尽可能地封装。 保持它简单与傻瓜（Keep it simple and stupid - KISS）不要让系统变得复杂，界面简洁，功能实用，操作方便，要让它足够的简单，足够的傻瓜。 高内聚与低耦合（High Cohesion and Low Coupling - HCLC）模块内部需要做到内聚度高，模块之间需要做到耦合度低。 惯例优于配置（Convention over Configuration - COC）尽量让惯例来减少配置，这样才能提高开发效率，尽量做到“零配置”。很多开发框架都是这样做的。 命令查询分离（Command Query Separation - CQS）在定义接口时，要做到哪些是命令，哪些是查询，要将它们分离，而不要揉到一起。 关注点分离（Separation of Concerns - SOC）将一个复杂的问题分离为多个简单的问题，然后逐个解决这些简单的问题，那么这个复杂的问题就解决了。难就难在如何进行分离。 契约式设计（Design by Contract - DBC）模块或系统之间的交互，都是基于契约（接口或抽象）的，而不要依赖于具体实现。该原则建议我们要面向契约编程。 你不需要它（You aren’t gonna need it - YAGNI）不要一开始就把系统设计得非常复杂，不要陷入“过度设计”的深渊。应该让系统足够的简单，而却又不失扩展性，这是其中的难点。]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F05%2F21%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射实现方式 实例化要反射的Class对象Class.forName(类名全路径); //通过Class的静态方法；对象.getClass() //通过对象.getClass方法；int.class //基本数据类型及基本数据类型的封装了，例如Integer； 获取父类Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Class&lt;?&gt; superclass = clazz.getSuperclass(); 获取实现接口Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Class&lt;?&gt;[] interfaces = clazz.getInterfaces() 获取指定参数构造函数及实例化Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Constructor&lt;?&gt; constructor = clazz.getConstructor(Class&lt;?&gt; ... class);//获取公共的 Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor()//获取私有的 constructor.newInstance(Object args); 获取所有构造函数及构造参数的类型Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors();//公共的 Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors()//包括私有的 for (int i = 0; i &lt; constructors.length; i++) { Class&lt;?&gt; clazzs[] = constructors[i].getParameterTypes();//获取类型 System.out.print(&quot;constructors[&quot; + i + &quot;] (&quot;); for (int j = 0; j &lt; clazzs.length; j++) { if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + &quot;,&quot;); } System.out.println(&quot;)&quot;); } 通过无参实例化对象Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 class.newInstance(); 获取字段，修改字段Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Field field = clazz.getField(String name);//获取公共字段 Field field = clazz.getDeclaredField(String name);//获取私有公共字段 Field[] field = clazz.getFields();//获取所有公共字段 Field[] field = clazz.getDeclaredFields();//获取包括私有所有字段 Field field = clazz.getDeclaredField(&quot;heihei&quot;); field.setAccessible(true);//设置java取消访问检查，也就是说如果是私有的也可以访问, field.set(obj, &quot;Java反射机制&quot;); 获取方法,运行方法Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 clazz.getMethod(String name ,Class&lt;?&gt; ... parame);//获取公共指定方法 clazz.getDeclaredMethod(String name ,Class&lt;?&gt; ... parame)//获取私有指定方法 clazz.getMethods()//获取公共所有方法 clazz.getDeclaredMethods();//获取包括私有全部方法 Method method = clazz.getMethod(&quot;add&quot;); method.invoke(clazz.newInstance()); method = clazz.getMethod(&quot;getInfo&quot;, int.class, String.class); method.setAccessible(true)//设置java取消访问检查，也就是说如果是私有的也可以访问, method.invoke(clazz.newInstance(), 20, &quot;张三&quot;); 获取数组或者list中的类型,如果不是数组或集合返回nullClass&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Class&lt;?&gt; componentType = clazz.getComponentType();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妞妞照片]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%A6%9E%E5%A6%9E%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>照片</category>
      </categories>
      <tags>
        <tag>妞妞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的妞妞]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%88%91%E7%9A%84%E5%A6%9E%E5%A6%9E%2F</url>
    <content type="text"><![CDATA[我的妞妞长的好看！！！美！！！]]></content>
      <tags>
        <tag>妞妞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜园子博客开始的地方]]></title>
    <url>%2F2018%2F05%2F21%2Fpost%2F</url>
    <content type="text"><![CDATA[打今天开始打理自己菜园子，菜园子有三块地，笔记、生活照片、记事本没啥说的，希望能够坚持下去，早点给自己定个目标吧。]]></content>
      <tags>
        <tag>给自己</tag>
      </tags>
  </entry>
</search>
