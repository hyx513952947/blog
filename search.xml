<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis 基本]]></title>
    <url>%2F2018%2F08%2F22%2Fdis-%E5%9F%BA%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Connection refused: no further information: localhost/127.0.0.1:6379 是没有开启服务，redis应该是类似与数据库类的，现在本地开启服务，不是web工程去开启写入信息的]]></content>
  </entry>
  <entry>
    <title><![CDATA[daker 后台服务（1）]]></title>
    <url>%2F2018%2F08%2F22%2Fker-%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开始使用 SpringBoot2.0 开始使用SpringBoot2.0作为daker的后台服务，暂时先把后台服务先写了，之后再快速将Android端完成，完善之后再进行小程序的开发 平台使用的ecliplse neno ，工程构建工具使用的maven，gradle不太会用，啊哈哈哈哈哈，尴尬的😀 按照正常网上的流程，ecliplse集成maven工具与SpringBoot的工具套件。 创建工程、根据提示配置工程名称、构建方式、打包格式、java版本等信息 集成工程依赖其中上面的几个都是应该跟微服务有关的，暂时应该先不管，先学会基础的就好 依赖库 构建一个完整的web项目中，功能模块对应依赖的库 MyBatis MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 redis 是一个由Salvatore Sanfilippo写的key-value存储系统。 devtoosl spring为开发者提供了一个名为spring-boot-devtools的模块来使Spring Boot应用支持热部署，提高开发者的开发效率，无需手动重启Spring Boot应用。 Validation提供了一系列验证各种参数的方法 retry 第三方接口或者使用mq时，会出现网络抖动，连接超时等网络异常，所以需要重试 Aspect 常用用于实现拦截的有：Filter、HandlerInterceptor、MethodInterceptor HandlerInterceptoer拦截的是请求地址，所以针对请求地址做一些验证、预处理等操作比较合适。当你需要统计请求的响应时间时MethodInterceptor将不太容易做到，因为它可能跨越很多方法或者只涉及到已经定义好的方法中一部分代码。 MethodInterceptor利用的是AOP的实现机制，在本文中只说明了使用方式，关于原理和机制方面介绍的比较少，因为要说清楚这些需要讲出AOP的相当一部分内容。在对一些普通的方法上的拦截HandlerInterceptoer就无能为力了，这时候只能利用AOP的MethodInterceptor。 Filter是Servlet规范规定的，不属于spring框架，也是用于请求的拦截。但是它适合更粗粒度的拦截，在请求前后做一些编解码处理、日志记录等。 Batch Spring Batch 是一个轻量级的、完善的批处理框架,旨在帮助企业建立健壮、高效的批处理应用。Spring Batch是Spring的一个子项目,使用Java语言并基于Spring框架为基础开发,使的已经使用 Spring 框架的开发者或者企业更容易访问和利用企业服务。 mail发送邮件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 音频记录]]></title>
    <url>%2F2018%2F07%2F16%2Fndroid-%E9%9F%B3%E9%A2%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[构造函数 public AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat,int bufferSizeInBytes) MediaRecorder.AudioSource音频来源]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义标签]]></title>
    <url>%2F2018%2F07%2F11%2F%E4%B9%89%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[功能要求： 包含父容器与子标签，容器内排列子标签 容器能自动排列子标签 标签能够删除、添加 删除添加有动画 要有几个常用的标签（时间、地点、天气、心情） 常用的标签不能删除 自定义标签能够删除 视图有删除按钮 标签设计： 标签分常用的和自定义 样式常用样式左侧有小图标 中间文字,右侧有删除图标，用于取消添加标签； 自定义的只需要在右侧有删除图标就可以咯； 功能左侧图标能够动态更改，右侧可以先写死，中间的就需要xml定义或者手动修改； xml属性值包含字体大小、字体颜色、是否显示左侧图标、右侧图标、点击事件处理]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Navigation使用]]></title>
    <url>%2F2018%2F07%2F06%2Fndroid-Navigation%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[链接地址 https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing 使用需要在三处地方进行操作： navigation目录下的xml文件，该文件是配置路由的配置信息，fragment之间的跳转、传值、deeplink链接 java代码中进行跳转 视图xml中对View配置 1.模块工程的.gradle文件种添加依赖2. resource资源目录下创建navigation目录保存使用的导航路由配置文件 根标签 navigation 各个参数的使用startDestination：配置默认展示的fragment id值 3. 此框架应该是方便activity对fragment的管理，而不是管理activities之间的跳转管理。4. 配置标签 fragment-]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS]]></title>
    <url>%2F2018%2F07%2F03%2FOS%2F</url>
    <content type="text"><![CDATA[侧滑框架优化:逻辑优化,结构优化 栏目切换优化:逻辑优化,自适应 新闻版式新增:轮播图,大图,多图,gif图,视频播放(窗口播放,全屏播放),标签 新闻详情:音频播放,分享等弹出框优化加载速度,加载优化 缓存优化:缓存阅读过的界面,数据库逻辑架构优化 加载优化:采用预缓存等技术加快加载速度 图片预览:更换预览框架. 搜索界面版式改进:搜索框样式,搜索历史]]></content>
  </entry>
  <entry>
    <title><![CDATA[中纪委升级优化方案]]></title>
    <url>%2F2018%2F07%2F03%2F%E7%BA%AA%E5%A7%94%E5%8D%87%E7%BA%A7%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[整体的方案大致是围绕页面和架构来写 架构 mvp模式 (1)降低耦合度 (2)模块职责划分明显 (3)利于测试驱动开发 (4)代码复用 (5)隐藏数据 (6)代码灵活性 Android的数据库 安全性 性能 图片缓存 能够离线查看 优化缓存 网络请求 替换原网络请求库 视频播放 支持更多格式视频 优化横竖版视频展示 优化视频播放 页面优化 轮播图自动轮播 轮播图能够自动轮询 栏目动态 详情页布局优化 标题过长导致显示不美观 新闻列表样式优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[java代理]]></title>
    <url>%2F2018%2F06%2F27%2Fva%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建动态代理 利用Java的Proxy类，调用Proxy.newProxyInstance()，创建动态对象十分简单。 InvocationHandler handler = new MyInvocationHandler(...); Class proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), new Class[] { Foo.class }); Foo f = (Foo) proxyClass.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler }); //或 Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class[] { Foo.class }, handler); 案例： public interface IVehical { void run(); } //concrete implementation public class Car implements IVehical{ public void run() { System.out.println(&quot;Car is running&quot;); } } //proxy class public class VehicalProxy { private IVehical vehical; public VehicalProxy(IVehical vehical) { this.vehical = vehical; } public IVehical create(){ final Class&lt;?&gt;[] interfaces = new Class[]{IVehical.class}; final VehicalInvacationHandler handler = new VehicalInvacationHandler(vehical); return (IVehical) Proxy.newProxyInstance(IVehical.class.getClassLoader(), interfaces, handler); } public class VehicalInvacationHandler implements InvocationHandler{ private final IVehical vehical; public VehicalInvacationHandler(IVehical vehical) { this.vehical = vehical; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;--before running...&quot;); Object ret = method.invoke(vehical, args); System.out.println(&quot;--after running...&quot;); return ret; } } } public class Main { public static void main(String[] args) { IVehical car = new Car(); VehicalProxy proxy = new VehicalProxy(car); IVehical proxyObj = proxy.create(); proxyObj.run(); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[笼统的资料]]></title>
    <url>%2F2018%2F06%2F27%2F%E7%BB%9F%E7%9A%84%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[1.java面向对象编程 三大特性： 封装、继承、多态； 栈内存、堆内存： 基本类型的变量和对象的引用变量都在函数的栈内存中分配；堆内存存放new创建的对象和数组； 1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与 C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 3. Java中的数据类型有两种。 一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知()，出于追求速度的原因，就存在于栈中。 2.软件功能模块设计（与设计模式相互补充 4.1） 1. 单一职责原则（Single Responsibility Principle - SRP） 原文：There should never be more than one reason for a class to change. 译文：永远不应该有多于一个原因来改变某个类。 理解：对于一个类而言，应该仅有一个引起它变化的原因。说白了就是，不同的类具备不同的职责，各施其责。这就好比一个团队，大家分工协作，互不影响，各做各的事情。 应用：当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！ 2. 开放封闭原则（Open Closed Principle - OCP） 原文：Software entities like classes, modules and functions should be open for extension but closed for modifications. 译文：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。 理解：简言之，对扩展开放，对修改封闭。换句话说，可以去扩展类，但不要去修改类。 应用：当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。 3. 里氏替换原则（Liskov Substitution Principle - LSP） 原文：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 译文：使用基类的指针或引用的函数，必须是在不知情的情况下，能够使用派生类的对象。 理解：父类能够替换子类，但子类不一定能替换父类。也就是说，在代码中可以将父类全部替换为子类，程序不会报错，也不会在运行时出现任何异常，但反过来却不一定成立。 应用：在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），子类尽量不要暴露自己的 public 方法供外界调用。 4. 最少知识原则（Least Knowledge Principle - LKP） 原文：Only talk to you immediate friends. 译文：只与你最直接的朋友交流。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。 应用：在做系统设计时，不要让一个类依赖于太多的其他类，需尽量减小依赖关系，否则，您死都不知道自己怎么死的。 5. 接口隔离原则（Interface Segregation Principle - ISP） 原文：The dependency of one class to another one should depend on the smallest possible interface. 译文：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。、理解：不要对外暴露没有实际意义的接口。也就是说，接口是给别人调用的，那就不要去为难别人了，尽可能保证接口的实用性吧。她好，我也好。 应用：当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，就意味着，您将来要多做一件事情，何苦要给自己找事做呢。 6. 依赖倒置原则（Dependence Inversion Principle - DIP） 原文：High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 译文：高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 理解：应该面向接口编程，不应该面向实现类编程。面向实现类编程，相当于就是论事，那是正向依赖（正常人思维）；面向接口编程，相当于通过事物表象来看本质，那是反向依赖，即依赖倒置（程序员思维）。 应用：并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧。 ------&gt;------&gt;------&gt;------&gt;------&gt;------&gt;------&gt; 将以上六大原则的英文首字母拼在一起就是 SOLID（稳定的），所以也称之为 SOLID 原则。只有满足了这六大原则，才能设计出稳定的软件架构！但它们毕竟只是原则，只是四人帮给我们的建议，有些时候我们还是要学会灵活应变，千万不要生搬硬套，否则只会把简单问题复杂化 补充设计原则 1. 组合/聚合复用原则（Composition/Aggregation Reuse Principle - CARP） 当要扩展类的功能时，优先考虑使用组合，而不是继承。这条原则在 23 种经典设计模式中频繁使用，如：代理模式、装饰模式、适配器模式等。可见江湖地位非常之高！ 2. 无环依赖原则（Acyclic Dependencies Principle - ADP） 当 A 模块依赖于 B 模块，B 模块依赖于 C 模块，C 依赖于 A 模块，此时将出现循环依赖。在设计中应该避免这个问题，可通过引入“中介者模式”解决该问题。 3. 共同封装原则（Common Closure Principle - CCP） 应该将易变的类放在同一个包里，将变化隔离出来。该原则是“开放-封闭原则”的延生。 4. 共同重用原则（Common Reuse Principle - CRP） 如果重用了包中的一个类，那么也就相当于重用了包中的所有类，我们要尽可能减小包的大小。 5. 好莱坞原则（Hollywood Principle - HP） 好莱坞明星的经纪人一般都很忙，他们不想被打扰，往往会说：Don&apos;t call me, I&apos;ll call you. 翻译为：不要联系我，我会联系你。对应于软件设计而言，最著名的就是“控制反转”（或称为“依赖注入”），我们不需要在代码中主动的创建对象，而是由容器帮我们来创建并管理这些对象。 其它设计原则 1. 不要重复你自己（Don&apos;t repeat yourself - DRY） 不要让重复的代码到处都是，要让它们足够的重用，所以要尽可能地封装。 2. 保持它简单与傻瓜（Keep it simple and stupid - KISS） 不要让系统变得复杂，界面简洁，功能实用，操作方便，要让它足够的简单，足够的傻瓜。 3. 高内聚与低耦合（High Cohesion and Low Coupling - HCLC） 模块内部需要做到内聚度高，模块之间需要做到耦合度低。 4. 惯例优于配置（Convention over Configuration - COC） 尽量让惯例来减少配置，这样才能提高开发效率，尽量做到“零配置”。很多开发框架都是这样做的。 5. 命令查询分离（Command Query Separation - CQS） 在定义接口时，要做到哪些是命令，哪些是查询，要将它们分离，而不要揉到一起。 6. 关注点分离（Separation of Concerns - SOC） 将一个复杂的问题分离为多个简单的问题，然后逐个解决这些简单的问题，那么这个复杂的问题就解决了。难就难在如何进行分离。 7. 契约式设计（Design by Contract - DBC） 模块或系统之间的交互，都是基于契约（接口或抽象）的，而不要依赖于具体实现。该原则建议我们要面向契约编程。 8. 你不需要它（You aren&apos;t gonna need it - YAGNI） 不要一开始就把系统设计得非常复杂，不要陷入“过度设计”的深渊。应该让系统足够的简单，而却又不失扩展性，这是其中的难点。 3.第三方的使用 第三方产厂商的sdk使用... 注意事项：兼容性、生产测试环境的隔离、bug收集、易用性 4.设计模式、数据结构 设计模式： 一 什么是设计模式？ （1）基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样 （2）Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。 （3）OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。 单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。 开闭原则：对修改封闭，对扩展放开。 里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。 接口隔离原则：将大接口改成多个小接口。 迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。 二 设计模式的分类 设计模式分为三种类型： （1）创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。（口诀：单原建造者，东西二厂） （2）结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。（口诀：一器一桥一元一代理；装饰组合外观） （3）行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。（口诀：三者两器、一录一链一模板，状态策略命令） 三 Android中的设计模式 （1）单例模式： 简介：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 示例：Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗。 比如LayoutInflater Service，将这些服务以键值对的形式存储在一个HashMap容器中，用户使用时只需要根据key来获取到对应的ServiceFetcher，然后通过ServcieFetcher对象的getService函数来获取到具体的服务对象，第一次获取时会调用ServcieFetcher的createService函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。 （2）抽象工厂模式： 简介：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 示例：Android底层对MediaPlayer的创建。MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。 （3）工厂模式： 简介：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。 （4）原型模式： 简介：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 示例：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。 （5）建造者模式： 简介：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 示例：AlertDialog.Builder ImageLoader的初始配置。 （6）适配器模式： 简介：将一个类的接口转换成客户希望的另外一个接口。 示例：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。 ListView或GridView的Adapter。 （7）桥接模式： 简介：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 示例：Window和WindowManager之间的关系。 在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。 （8）装饰模式： 简介：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。 （9）组合模式： 简介：将对象组合成树形结构以表示“部分-整体”的层次结构。 示例：View和ViewGroup的组合 （10）外观模式 简介：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。 示例：ContextImpl （11）享元模式： 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。 （12）代理模式： 简介：为其他对象提供一个代理以控制对这个对象的访问。 示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。 （13）观察者模式： 简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。 示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。 （14）中介者模式： 简介：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 示例：Binder机制。 (15)访问者模式: 简介：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。 （16） 解释器模式： 简介：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程， （17）迭代器模式 简介：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。 （18）备忘录模式 简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。 （19）责任链模式 简介：有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 示例: 责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。 （20）状态模式： 简介：状态发生改变时，行为改变。 示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。 （21）策略模式 简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。 示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。 （22）命令模式 简介：把请求封装成一个对象发送出去，方便定制、排队、取消。 示例：Handler.post后Handler.handleMessage。 （23）享元模式 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。 数据：三个重要的接口与线程安全与有序无序 1.List 列表 arraylist、vector是线性表使用object数组作为容器去存储数据，长度动态增长。array是非同步的，vector是同步的。 LinkedList是链表，链表随机位置插入、删除数据时比线性表快，遍历比线性表慢。 ArrayList（非同步、非频繁删除时选择）、Vector（需同步时选择）、LinkedList（频繁在任意位置插入、删除时选择） 2.Set 唯一集合 Set结构其实就是维护一个Map来存储数据的，利用Map结构key值唯一性。 3.Map 键值对应 key唯一 HashMap 结构的实现原理是将put进来的key-value封装成一个Entry对象存储到一个Entry数组中，位置（数组下标）由key的哈希值与数组长度计算而来。如果数组当前下标已有值，则将数组当前下标的值指向新添加的Entry对象。 TreeMap 是由Entry对象为节点组成的一颗红黑树，put到TreeMap的数据默认按key的自然顺序排序，new TreeMap时传入Comparator自定义排序。 HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModif:icationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。 工具类：Collections 集合的差集、并集、拷贝、排序等等 数据结构： 数组、有序数组、栈、队列、链表、二叉树、红黑树、2-3-4树、哈希表、堆、图； 重点红黑树！！！&lt;-------------重点 5.多线程、图形、网络编程 线程: 一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。线程的实现方式有三种runnable（接口），thread（类），callable（接口可集成别的类） 守护线程： User Thread(用户线程)、DaemonThread(守护线程)。 主线程中建立一个守护线程，当主线程结束时，守护线程也跟着结束。守护线程主要为了别的线程服务；当所有的用户线程都不存在才会自动退出。 线程状态： 新建状态、就绪状态、运行状态、阻塞状态（等待阻塞；同步阻塞，线程获取同步锁失败；其他阻塞）、死亡状态； 线程同步： synchronized ： 一 、修饰方法 public synchronized void saveValue（）{}； 二 、同步方法 synchronized (this){index+=dex;}； volatile： a：volatile关键字为域变量的访问提供了一种免锁机制 b：使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， c：因此每次使用该域就要重新计算，而不是使用寄存器中的值 d：volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 ReentrantLock（类）： Lock lock = new ReentrantLock(); lock.lock(); //上锁 ... lock.unlock(); //解锁 ThreadLocal管理变量： 一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。 ThreadLocal() : 创建一个线程本地变量 get() : 返回此线程局部变量的当前线程副本中的值 initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot; set(T value) : 将此线程局部变量的当前线程副本中的值设置为value LinkedBlockingQueue与ArrayBlockingQueue: Java并发中阻塞队列 ------------------------------------------------- ------------------------------------------------- 图形编程： hencoder.com ----&gt; 头2章 ------------------------------------------------- ------------------------------------------------- 网络编程: TCP： TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP： UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。 以上两个太特么难了，不整了 Socket 编程: 网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户端和服务端的连接。Socket是TCP/IP协议的一个十分流行的编程实现，一个Socket由一个IP地址和一个端口号唯一确定。 但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。 Server端Listen(监听)某个端口是否有连接请求，Client端向Server端发出Connect(连接)请求，Server端向Client端发回Accept（接受）消息。一个连接就建立起来了。Server端和Client 端都可以通过Send，Write等方法与对方通信。 对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤： （1） 创建Socket； （2） 打开连接到Socket的输入/出流； （3） 按照一定的协议对Socket进行读写操作； （4） 关闭Socket。 6.动画、页面优化 xml动画（alpha、scale、translate、rotate、set）： scale(fromXScale、toXScale、fromYscale、pivotX:&apos; 50、50%、50%p&apos;); alpha; rotate; translate; set; Interpolator 插值器(系统默认): AccelerateDecelerateInterpolator 在动画开始与介绍的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator 开始的时候向后然后向前甩 AnticipateOvershootInterpolator 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator 动画结束的时候弹起 CycleInterpolator 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator 在动画开始的地方快然后慢 LinearInterpolator 以常量速率改变 OvershootInterpolator 向前甩一定值后再回到原来位置 代码生成动画（Animation的子类实现）： 不同的构造参数代表实现动画的不同属性，需要针对去查看 属性动画（Property Animator 包括 ValueAnimator 和 ObjectAnimator）： ValueAnimator： TimeInterpolator: 实现自定义插值器 Evaluator（ 继承 TypeEvaluator）： 动画进度的数值转换 ArgbEvalutor： 颜色数值转换器 PointEvaluator ： Point点值返回 ofObject: 对象 ObjectAnimator（派生自 ValueAnimator，能用他的所有方法）: public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) 实现方法； alpha,rotaion(rotation、rotationX、rotationY),translate(translationX、translationY),scale(scaleX、scaleY)是第二个参数的值，能够直接实现的动画效果； 自定义ObjectAnimator主要是能够实现第二个参数的seter方式要名称一致（&quot;big&quot;--&gt;setBig(value)）； PropertyValuesHolder（ObjectAnimator.ofPropertyValuesHolder（...））: 控制视图的单个属性，传如多个能够控制多种属性变换。 Keyframe(关键帧，在某一时间的停留位置状态，为了照顾我等不会计算的人)： PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)； 利用关键帧创建 PropertyValuesHolder 后，一定要记得设置自定义的 Evaluator；ofObject 来做动画的时候，都必须调用 frameHolder.setEvaluator 显示设置 Evaluator LayoutAnimation： xml配置有效的字段： delay（animation动画的倍数）、 animationOrder（顺序 normal、reverse、random）、 animation GridLayoutAnimation： rowDelay（每一行动画开始的延迟）、 columnDelay（每一列动画开始的延迟）、 directionPriority（方向优先级。取值为 row,collumn,none）、direction（left_to_right：列，从左向右开始动画 right_to_left ：列，从右向左开始动画 top_to_bottom：行，从上向下开始动画 bottom_to_top：行，从下向上开始动画）、 animation； animateLayoutChanges（api &gt;= 11）： 以上2种的动画只是在创建的时候第一次才会有动画，再添加数据不会有动画出现； 设置为true; LayoutTransaction: 用来添加自定义动画，否则animateLayoutChanges只是显示默认的动画； LayoutTransaction transitioner = new LayoutTransition(); ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f); transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); int transitionType：表示当前应用动画的对象范围，取值有： APPEARING —— 元素在容器中出现时所定义的动画。 DISAPPEARING —— 元素在容器中消失时所定义的动画。 CHANGE_APPEARING —— 由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画 CHANGE_DISAPPEARING —— 当容器中某个元素消失，其它需要变化的元素所应用的动画 7.js、ES6、html5 ES6： 新特性： 变量声明const和let： 之前使用var关键字生i没那个变量，无论声明在何处，都会视为声明在函数的最顶端，不在函数内，是在全局作用域的最顶端，es6后ley表示变量，const表示常量，let和const都是块级作用域（函数内部、或一个代码块内部，{}），const是一个常量，只要是指向得地址没改变就行，指向一个对象，对象得值改变能够接受； 模板字符串： 字符串中使用${name}进行格式化，``反引号换行拼接`************`,includes(),repeat(),startsWith(),endsWidth(); 函数默认参数： function action(num = 200){}； 函数箭头函数： 不需要function关键字来创建函数； 省略return 关键字； 继承当前上下文得this关键字； 跟java得差不多 扩展得对象功能： 对象初始化简写：function person(name,age){ return{name,age}; }; Object.assign(),浅拷贝 数据访问结构： const(name,age)= pserson; Spread Operator展开运算符： 三个点：...; const color = [&apos;red&apos;, &apos;yellow&apos;] const colorful = [...color, &apos;green&apos;, &apos;pink&apos;] 或 const number = [1,2,3,4,5] const [first, ...rest] = number import和export： 导入模块和导出模块： //全部导入 import people from &apos;./example&apos; //有一种特殊情况，即允许你将整个模块当作单一对象进行导入 //该模块的所有导出都会作为对象的属性存在 import * as example from &quot;./example.js&quot; //导入部分 import {name, age} from &apos;./example&apos; // 导出默认, 有且只有一个默认 export default App // 部分导出 export class App extend Component {}; 1.当用export default people导出时，就用 import people 导入（不带大括号） 2.一个文件里，有且只能有一个export default。但可以有多个export。 3.当用export name 时，就用import { name }导入（记得带上大括号） 4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } 5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example Promise： 同步的方式去写异步代码。 Generators： 生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。 当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。 // 生成器 function *createIterator() { yield 1; yield 2; yield 3; } // 生成器能像正规函数那样被调用，但会返回一个迭代器 let iterator = createIterator(); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 Proxies: 代理，监听数据对象变化。 8.区块链 去中心化，概率值越大越不容易获取，sha64 9.http协议 客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。 通用头域： Cache-Control: 请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached; 响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。 Keep-Alive: KeepAliveTime:验证连接有效的频率。 Date： 消息发送的时间。 Pragma： 包含实现特定的指令 请求消息： 请求头域可能包含下列字段Accept、Accept-Charset、Accept-Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。 相应消息： code值的返回状态意义--&gt; 1xx:信息响应类，表示接收到请求并且继续处理 2xx:处理成功响应类，表示动作被成功接收、理解和接受 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 5xx:服务端错误，服务器不能正确执行一个正确的请求 Location响应头: Location响应头用于重定向接收者到一个新URI地址。 Server响应头: Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。 实体信息: 请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。 Content-Type实体头: Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型 Content-Range实体头 Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth 10.websocket（js） 服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 1.建立在 TCP 协议之上，服务器端的实现比较容易。 2.与HTTP协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 3.数据格式比较轻量，性能开销小，通信高效。 4.可以发送文本，也可以发送二进制数据。 5.没有同源限制，客户端可以与任意服务器通信。 6.协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 var Socket = new WebSocket(url, [protocol] ); open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 11.RESTful 1.Rest架构的主要原则 网络上的所有事物都被抽象为资源 每个资源都有一个唯一的资源标识符 同一个资源具有多种表现形式(xml,json等) 对资源的各种操作不会改变资源标识符 所有的操作都是无状态的 符合REST原则的架构方式即可称为RESTful 12.react13.glide14.LeakCanary15.dexclassloader16.Android 热更新 classloader： 插件化还是组件化，都是基于系统的ClassLoader来设计的。只不过Android平台上虚拟机运行的是Dex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。 Android中的ClassLoader： BootClassLoader、URLClassLoader、PathClassLoader、DexClassLoader、DexClassLoader、BaseDexClassLoader，全部继承自ClassLoader； Android中默认无父构造器的传入情况下，默认父构造器是一个PathClassLoader，该类的父构造器是BootClassLoader，主要方法为loadClass（String className,boolean resolve）加载类，如果类是重复的就不会对类进行加载。 BootClassLoader： 与Java虚拟机中不同的是BootClassLoader是ClassLoader的内部类，由java实现，Android中的classLoader的最终父类，内部类不可见。 URLClassLoader: 加载jar文件，由于dalvik不能直接识别jar，在Android中无法使用这个加载器。 BaseDexClassLoader： PathClassLoader与DexClassLoader都继承自BaseDexClassLoader，主要逻辑是在BaseDexClassLoader中完成。 四个参数： dexPath,指目标类所在的APK或jar文件的路径,类装载器将从该路径中寻找指定的目标类,该类必须是APK或jar的全路径.如果要包含多个路径,路径之间必须使用特定的分割符分隔,特定的分割符可以使用System.getProperty(“path.separtor”)获得。上面&quot;支持加载APK、DEX和JAR，也可以从SD卡进行加载&quot;指的就是这个路径，最终做的是将dexPath路径上的文件ODEX优化到内部位置optimizedDirectory，然后，再进行加载的。 File optimizedDirectory,由于dex文件被包含在APK或者Jar文件中,因此在装载目标类之前需要先从APK或Jar文件中解压出dex文件,该参数就是制定解压出的dex 文件存放的路径。这也是对apk中dex根据平台进行ODEX优化的过程。其实APK是一个程序压缩包，里面包含dex文件，ODEX优化就是把包里面的执行程序提取出来，就变成ODEX文件，因为你提取出来了，系统第一次启动的时候就不用去解压程序压缩包的程序，少了一个解压的过程。这样的话系统启动就加快了。为什么说是第一次呢？是因为DEX版本的也只有第一次会解压执行程序到 /data/dalvik-cache（针对PathClassLoader）或者optimizedDirectory(针对DexClassLoader）目录，之后也是直接读取目录下的的dex文件，所以第二次启动就和正常的差不多了。当然这只是简单的理解，实际生成的ODEX还有一定的优化作用。ClassLoader只能加载内部存储路径中的dex文件，所以这个路径必须为内部路径。 libPath,指目标类中所使用的C/C++库存放的路径 classload,是指该装载器的父装载器,一般为当前执行类的装载器，例如在Android中以context.getClassLoader()作为父装载器。 DexClassLoader： 四个参数： DexClassLoader支持加载APK、DEX和JAR，也可以从SD卡进行加载。 上面说dalvik不能直接识别jar,DexClassLoader却可以加载jar文件,这难道不矛盾吗?其实在BaseDexClassLoader里对&quot;.jar&quot;,&quot;.zip&quot;,&quot;.apk&quot;,&quot;.dex&quot;后缀的文件最后都会生成一个对应的dex文件,所以最终处理的还是dex文件,而URLClassLoader并没有做类似的处理。 一般我们都是用这个DexClassLoader来作为动态加载的加载器。 PathClassLoader： 三个参数：并无optimizedDirectory，直接设为null； PathClassLoader将optimizedDirectory置为Null,也就是没设置优化后的存放路径。其实optimizedDirectory为null时的默认路径就是/data/dalvik-cache 目录。 PathClassLoader是用来加载Android系统类和应用的类，并且不建议开发者使用。 ART虚拟机的兼容性问题： Android Runtime（缩写为ART），在Android 5.0及后续Android版本中作为正式的运行时库取代了以往的Dalvik虚拟机。ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机。它与Dalvik的主要不同在于：Dalvik采用的是JIT技术，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而ART采用Ahead-of-time（AOT）技术，应用在第一次安装的时候，字节码就会预先编译成机器码，这个过程叫做预编译。ART同时也改善了性能、垃圾回收（Garbage Collection）、应用程序除错以及性能分析。但是请注意，运行时内存占用空间较少同样意味着编译二进制需要更高的存储。 ART模式相比原来的Dalvik，会在安装APK的时候，使用Android系统自带的dex2oat工具把APK里面的.dex文件转化成OAT文件，OAT文件是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。ART模式的系统里，同样存在DexClassLoader类，包名路径也没变，只不过它的具体实现与原来的有所不同，但是接口是一致的。实际上，ART运行时就是和Dalvik虚拟机一样，实现了一套完全兼容Java虚拟机的接口。 17.Android插件化开发： 代理（静态代理、动态代理）、hook、java反射; java反射： 1.实例化Class对象，有三种方式， Class.forName(类名全路径); //通过Class的静态方法 对象.getClass() //通过对象.getClass方法 int.class //基本数据类型及基本数据类型的封装了，例如Integer 2.获取父类 Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Class&lt;?&gt; superclass = clazz.getSuperclass(); 3.获取实现接口 Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Class&lt;?&gt;[] interfaces = clazz.getInterfaces() 4.获取指定参数构造函数及实例化 Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Constructor&lt;?&gt; constructor = clazz.getConstructor(Class&lt;?&gt; ... class);//获取公共的 Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor()//获取私有的 constructor.newInstance(Object args); 5.获取所有构造函数及构造参数的类型 Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors();//公共的 Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors()//包括私有的 for (int i = 0; i &lt; constructors.length; i++) { Class&lt;?&gt; clazzs[] = constructors[i].getParameterTypes();//获取类型 System.out.print(&quot;constructors[&quot; + i + &quot;] (&quot;); for (int j = 0; j &lt; clazzs.length; j++) { if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + &quot;,&quot;); } System.out.println(&quot;)&quot;); } 6.通过无参实例化对象 Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 class.newInstance(); 7.获取字段，修改字段 Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Field field = clazz.getField(String name);//获取公共字段 Field field = clazz.getDeclaredField(String name);//获取私有公共字段 Field[] field = clazz.getFields();//获取所有公共字段 Field[] field = clazz.getDeclaredFields();//获取包括私有所有字段 Field field = clazz.getDeclaredField(&quot;heihei&quot;); field.setAccessible(true);//设置java取消访问检查，也就是说如果是私有的也可以访问, field.set(obj, &quot;Java反射机制&quot;); 8.获取方法,运行方法 Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 clazz.getMethod(String name ,Class&lt;?&gt; ... parame);//获取公共指定方法 clazz.getDeclaredMethod(String name ,Class&lt;?&gt; ... parame)//获取私有指定方法 clazz.getMethods()//获取公共所有方法 clazz.getDeclaredMethods();//获取包括私有全部方法 Method method = clazz.getMethod(&quot;add&quot;); method.invoke(clazz.newInstance()); method = clazz.getMethod(&quot;getInfo&quot;, int.class, String.class); method.setAccessible(true)//设置java取消访问检查，也就是说如果是私有的也可以访问, method.invoke(clazz.newInstance(), 20, &quot;张三&quot;); 9.获取数组或者list中的类型,如果不是数组或集合返回null Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Class&lt;?&gt; componentType = clazz.getComponentType(); 18.bitmap的重复使用19.LeakCanary20.activiti manager ；window manager； content providers； package manager ；resource manager ；view system:21.View点击事件： 1 getAction:触摸动作的原始32位信息，包括事件的动作，触控点信息： 一个点击事件的所有信息，坐标点、触摸事件、是哪个手指头点的 2 getActionMask:触摸的动作,按下，抬起，滑动，多点按下，多点抬起： 单纯的触摸事件 3 getActionIndex:触控点信息： 触摸点 都会回调到onTouchEvent()方法中，多点触摸处就根据3-&gt;2 旋转手势： GestureDetector与ScaleGestureDetector； 22.广播： 本地广播：LocalBroadcastManager，只在应用内接受发送广播； 普通广播有序广播：普通是异步方式全部发送，有序广播按照顺序发送每次只给一个发送，有序广播能够在被接收到后反馈数据、终止继续下发; 23.线程池：(https://blog.csdn.net/tuke_tuke/article/details/51353925 说的比较详细) ExecutorService： Executor接口是Executor框架中最基础的部分，定义了一个用于执行Runnable的execute方法，它没有实现类只有另一个重要的子接口ExecutorService； ExecutorService接口继承自Executor接口，定义了终止、提交,执行任务、跟踪任务返回结果等方法 1.execute（Runnable command）：履行Ruannable类型的任务, 2.submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future对象 3.shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务, 4.shutdownNow（）：停止所有正在履行的任务并封闭办事。 5.isTerminated（）：测试是否所有任务都履行完毕了。, 6.isShutdown（）：测试是否该ExecutorService已被关闭 Executors: 负责生成各种类型的ExecutorService线程池实例; +newFixedThreadPool(numberOfThreads:int):（固定线程池）ExecutorService 创建一个固定线程数量的线程池，并行执行的线程数量不变，线程当前任务完成后，可以被重用执行另一个任务 +newCachedThreadPool():（可缓存线程池）ExecutorService 创建一个线程池，按需创建新线程，就是有任务时才创建，空闲线程保存60s，当前面创建的线程可用时，则重用它们 +new SingleThreadExecutor(); （单线程执行器）线程池中只有一个线程，依次执行任务 +new ScheduledThreadPool()： 线程池按时间计划来执行任务，允许用户设定执行任务的时间 +new SingleThreadScheduledExcutor(); 线程池中只有一个线程，它按规定时间来执行任务 Feature: Future代表异步任务的执行结果; Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果; +cancel 方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。 +isCancelled 方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。 +isDone 方法表示任务是否已经完成，若任务完成，则返回true； +get() 方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回； +get(long timeout, TimeUnit unit) 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。 也就是说Future提供了三种功能： 1）判断任务是否完成； 2）能够中断任务； 3）能够获取任务执行结果。 24.OAuth2: 基本流程： （A）用户打开客户端以后，客户端请求资源所有者（用户）的授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请访问令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放访问令牌。 （E）客户端使用访问令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源。 授权的四种模式： 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials） 25.scrollView嵌套ListView滑动冲突显示不正确: https://www.jianshu.com/p/9abf6a874feb 26.一天一面： https://www.jianshu.com/p/1d3a2227fb72 知识点是挺基础在平时也是挺使用的，需要定期看下]]></content>
  </entry>
  <entry>
    <title><![CDATA[ViewGroup一些相关的类]]></title>
    <url>%2F2018%2F06%2F26%2FewGroup%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[setWillNotDraw() 在viewgroup初始化的时候，它调用了一个私有方法：initViewGroup --&gt; setFlags（WILLL_NOT_DRAW,DRAW_MASK)，不会调用ondraw（）方法，自定义viewgroup时候需要setWillNotDraw(false)； descendantfocusability viewgroup控件在代码中或者xml中能设置该属性： FOCUS_BEFORE_DESCENDANTS ViewGroup本身先对焦点进行处理，如果没有处理则分发给child View进行处理 FOCUS_AFTER_DESCENDANTS 先分发给Child View进行处理，如果所有的Child View都没有处理，则自己再处理 FOCUS_BLOCK_DESCENDANTS ViewGroup本身进行处理，不管是否处理成功，都不会分发给ChildView进行处理 ViewCompat 这个是解决版本兼容性的 ViewPager内部的view根据位置绘制的，缓存多少个就在相邻位置绘制多少个]]></content>
  </entry>
  <entry>
    <title><![CDATA[gradle 笔记01]]></title>
    <url>%2F2018%2F06%2F25%2Fradle-%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[任务的按照dofirst{}dolast{}顺序执行&lt;&lt; 符号是dolast的别名ext是创建的任务的额外任务属性]]></content>
  </entry>
  <entry>
    <title><![CDATA[Canvan的几个方法含义]]></title>
    <url>%2F2018%2F06%2F11%2Fnvan%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[save保存当前绘制属性，画布坐标变化之前的状态 restore绘制属性回退到上一个保存堆栈的上一个状态]]></content>
  </entry>
  <entry>
    <title><![CDATA[Shader]]></title>
    <url>%2F2018%2F06%2F11%2Fader%2F</url>
    <content type="text"><![CDATA[着色器 LinearGradient 线性变色，Shader shader = new LinearGradient(0, 0, 100, 100, Color.RED, Color.GREEN, Shader.TileMode.REPEAT); 参数：第一个是x开始坐标，第二个是y开始坐标，三、四结束x、y坐标，左边是根据view的坐标系开始计算的，五是模式：重复还是扩展、镜像 RadialGradient辐射渐变，由一中心点渐变 SweepGradient 像雷达一样 BitmapShader 图像BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY) ComposeShader多个着色器组合使用 new ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER);]]></content>
  </entry>
  <entry>
    <title><![CDATA[手势监听]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%8A%BF%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[手势监听 VelocityTracker加速度监听 obtain()：实例化 addMovement(MotionEvent event)：添加事件 recycle()：回收]]></content>
  </entry>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2F2018%2F05%2F30%2Fl%2F</url>
    <content type="text"><![CDATA[https://www.studytutorial.in/android-sending-xml-or-soap-rest-api-request-using-okhttp-tutorial]]></content>
  </entry>
  <entry>
    <title><![CDATA[WorkManager]]></title>
    <url>%2F2018%2F05%2F29%2ForkManager%2F</url>
    <content type="text"><![CDATA[WorkManager 主要的类 WorkManager：管理任务，开启任务 WorkManager 方法WorkManager getInstance()： 获取实例 initialize(@NonNull Context context, @NonNull Configuration configuration)： 获取实例，参数二配置线程池 enqueue(@NonNull WorkRequest... workRequest)： 添加后台任务 enqueue(@NonNull List&lt;? extends WorkRequest&gt; baseWork)： 添加后台任务 WorkContinuation beginWith(@NonNull OneTimeWorkRequest...work)： 开启不需要重复的任务，它只执行一遍，返回值WorkContinuation 是用来开启任务链的； 能够与其他的进行then、combine操作 WorkContinuation beginWith(@NonNull List&lt;OneTimeWorkRequest&gt; work)； 开启一组的上述任务 WorkContinuation beginUniqueWork( @NonNull String uniqueWorkName, @NonNull ExistingWorkPolicy existingWorkPolicy, @NonNull OneTimeWorkRequest... work) ： 该方法第一个参数是任务名称，名称是唯一的不能够重复；第二个参数ExistingWorkPOneTimeWorkRequestolicy是用来判断如果出现了重复的，是替换还是追加、还是不理会 继续保持当前的任务目标不变； cancelWorkById(@NonNull UUID id)： 根据uuid去取消任务，但是方法的调用不一定回起作用，如果正在执行，那么将不会取消，任务会正常的去完成。 void cancelAllWorkByTag(@NonNull String tag)： 与上相似。 void cancelUniqueWork(@NonNull String uniqueWorkName) 字面意思。 LiveData&lt;WorkStatus&gt; getStatusById(@NonNull UUID id); 能够监听任务的完成情况。 LiveData&lt;List&lt;WorkStatus&gt;&gt; getStatusesByTag(@NonNull String tag)： 字面。 LiveData&lt;List&lt;WorkStatus&gt;&gt; getStatusesForUniqueWork( @NonNull String uniqueWorkName)： 字面。 SynchronousWorkManager synchronous()： 返回的对象方法什么的跟原来的WorkManager方法都差不多，这个是同步方法，不能在主线程中运行。在子线程中使用，能直接知道是否添加成功 WorkRequest 任务请求 OneTimeWorkRequest 不重复的请求，执行一次； PeriodicWorkRequest重复执行 WorkSpec存入数据库的一些任务调度信息，时间、任务信息等 Worker 任务基本单元，有已经实现好的几个类，自己实现只需要复写 dowork就可以，类单独写，不能是内部类实现，否则实例化不了。通过get方法能获取到传递的所有信息数据。下列出已经实现的该类的对象。 CombineContinuationsWorker工作任务流组合，能够像链条一样 ConstraintTrackingWorker当约束符合条件,可以传如参数（类名称），通过不同参数实现不同代理 Constraints 约束，设定任务在什么系统的什么情况下能够启动 mRequiredNetworkType什么网络条件下启动 mRequiresCharging 充电 mRequiresDeviceIdle休眠 mRequiresBatteryNotLow电量不高 mRequiresStorageNotLow内存不高 mContentUriTriggersuri触发启动]]></content>
  </entry>
  <entry>
    <title><![CDATA[定时任务的一个库]]></title>
    <url>%2F2018%2F05%2F29%2F%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%93%2F</url>
    <content type="text"><![CDATA[地址 https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/能够根据不同版本去选择不同方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[书签]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt; Bookmarks Bookmarks 书签栏 Android Api Guide 中国软件与技术服务股份有限公司邮件登录 okhttp3 (OkHttp 3.4.1 API) Realm: Create reactive mobile apps in a fraction of the time HTML/CSS Flex 布局教程：实例篇 - 阮一峰的网络日志 Flex 布局教程：语法篇 - 阮一峰的网络日志 GitHub - googlesamples/android-architecture: A collection of samples to discuss and showcase different architectural tools and patterns for Android apps. GitHub - googlesamples/android-architecture-components: Samples for Android Architecture Components. 一个github上不错的工具类分享 - CSDN博客 HenCoder「仿写酷界面」活动——征稿 Most Popular - LottieFiles 我所经历的Android面试|掘金技术征文 - 掘金 GitHub - alibaba/ARouter: An android router middleware that help app navigating to activities and custom services. GitHub - CyC2018/Interview-Notebook: 技术面试需要掌握的基础知识整理，欢迎编辑~ Android 知识体系脑图「android篇」 | bug 鸣泣之时 ［Android基础］Android总结篇 - CSDN博客 10个优秀个android项目，精选|快速开发 – Android开发中文站 AndroidXRef Android 开源项目集合 下班后，可以通过什么方式赚钱？ - 简书 Android开发中文站–关注Android，关注开发者 Gradle 教程 - Android Studio 安卓开发者社区 分享文件 | Android官方培训课程中文版(v0.9.7) 央视App]]></content>
  </entry>
  <entry>
    <title><![CDATA[产品基本流程]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[产品定位 需求分析 需求筛选 商业价值 5W2H?what,who,where,when,why? how,how much?]]></content>
  </entry>
  <entry>
    <title><![CDATA[vpn]]></title>
    <url>%2F2018%2F05%2F25%2Fpn%2F</url>
    <content type="text"><![CDATA[搬瓦工账号：513952947@qq.com密码；** w服务器地址 服务器安装： wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh 安装wget yum -y install wget 更改运行脚本权限 chmod +x shadowsocks-all.sh 运行脚本 ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 保存信息 保存服务ip端口号密码等信息 终端软件安装 ios：https://itunes.apple.com/us/app/wingy-proxy-for-http-s-socks5/id1178584911?mt=8 Android：https://github.com/shadowsocks/shadowsocks-android/releases windows：https://github.com/shadowsocks/shadowsocks-windows/releases ubuntu：sudo apt-get update sudo apt-get install python-pip sudo apt-get install python-setuptools m2crypto pip install shadowsocks sudo apt install shadowsocks sslocal -s [ip地址] -p [端口号] -k [密码] -l [1080本地端口] -t [超时] -m aes-256-cfb]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 矢量图动画]]></title>
    <url>%2F2018%2F05%2F25%2Fndroid-%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[矢量图来源 在Android中正常的是： f &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ...&gt; &lt;path/&gt; &lt;/vector&gt; vector标签中包含路径，动画就需要使用&lt;group&gt; path... &lt;/group&gt;包裹路径，并对包裹路径的group设置动画属性来控制该标签内的路径变化； xml实现动画方式 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;vector图片&quot;&gt; &lt;target android:animation=&quot;@animator/动画xml&quot; android:name=&quot;要做动画的path、在group中path的定义名称&quot;/&gt; &lt;target android:name=&quot;要做动画的path&quot; android:animation=&quot;@animator/smile_morph&quot;/&gt; &lt;/animated-vector&gt; AnimatedVectorDrawable smileDrawable = (AnimatedVectorDrawable) imageView.getDrawable(); smileDrawable.start();调用 java代码实现方式 矢量图动画网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[Palette]]></title>
    <url>%2F2018%2F05%2F25%2Falette%2F</url>
    <content type="text"><![CDATA[Palette‘com.android.support:palette-v7:27.1.1’ Vibrant: 亮色 Vibrant dark: 深亮色 Vibrant light: 浅亮色 Muted: 暗色 Muted dark: 深暗色 Muted light: 浅暗色]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>颜色提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android statusBar]]></title>
    <url>%2F2018%2F05%2F25%2Fdroid-statusBar%2F</url>
    <content type="text"><![CDATA[View mDecorView; private static String TAG = &quot;StatusBarActivity&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mDecorView = findViewById(android.R.id.content); mDecorView.setOnSystemUiVisibilityChangeListener(new View.OnSystemUiVisibilityChangeListener() { @Override public void onSystemUiVisibilityChange(int visibility) { // Note that system bars will only be &quot;visible&quot; if none of the // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set. if ((visibility &amp; View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) { // TODO: The system bars are visible. Make any desired // adjustments to your UI, such as showing the action bar or // other navigational controls. } else { // TODO: The system bars are NOT visible. Make any desired // adjustments to your UI, such as hiding the action bar or // other navigational controls. } } }); showSystemUI(); setContentView(R.layout.activity_status_bar); findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { hideSystemUI(); } }); } private void showSystemUI() { //显示状态栏 mDecorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); } private void hideSystemUI() { // Set the IMMERSIVE flag. 设置沉浸式 //SYSTEM_UI_FLAG_IMMERSIVE_STICKY 内滑显示状态栏 会自动消失 //SYSTEM_UI_FLAG_IMMERSIVE 内滑显示状态栏 不会自动消失 // Set the content to appear under the system bars so that the content // doesn&apos;t resize when the system bars hide and show. mDecorView.setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>statusBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FileProvider]]></title>
    <url>%2F2018%2F05%2F24%2FFileProvider%2F</url>
    <content type="text"><![CDATA[为了给应用程序定义一个FileProvider，需要在Manifest清单文件中定义一个entry，该entry指明了需要使用的创建Content URI的Authority。此外，还需要一个XML文件的文件名，该XML文件指定了我们的应用可以共享的目录路径。 下例展示了如何在清单文件中添加标签，来指定FileProvider类，Authority及XML文件名： &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapp&quot;&gt; &lt;application ...&gt; &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.example.myapp.fileprovider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/filepaths&quot; /&gt; &lt;/provider&gt; ... &lt;/application&gt; &lt;/manifest&gt; 在“res/xml/”下创建文件“filepaths.xml”。在这个文件中，为每一个想要共享目录添加一个XML标签 &lt;paths&gt; &lt;files-path path=&quot;images/&quot; name=&quot;myimages&quot; /&gt; &lt;/paths&gt; 标签共享的是在我们应用的内部存储中“files/”目录下的目录。“path”属性字段指出了该子目录为“files/”目录下的子目录“images/”。“name”属性字段告知FileProvider在“files/images/”子目录中的文件的Content URI添加路径分段（path segment）标记：“myimages”。 标签可以有多个子标签，每一个子标签用来指定不同的共享目录。除了标签，还可以使用来共享位于外部存储的目录；另外，标签用来共享在内部缓存目录下的子目录。 在文件分享是时调用给与临时的权限： Intent.addFlags( Intent.FLAG_GRANT_READ_URI_PERMISSION);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>FileProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络连接检测]]></title>
    <url>%2F2018%2F05%2F24%2Fdroid-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[检测是否连接 private static final String DEBUG_TAG = &quot;NetworkStatusExample&quot;; ConnectivityManager connMgr = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI); boolean isWifiConn = networkInfo.isConnected(); networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); boolean isMobileConn = networkInfo.isConnected(); Log.d(DEBUG_TAG, &quot;Wifi connected: &quot; + isWifiConn); Log.d(DEBUG_TAG, &quot;Mobile connected: &quot; + isMobileConn);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 打印当前行数和名称方法]]></title>
    <url>%2F2018%2F05%2F24%2Fdroid-%E6%89%93%E5%8D%B0%E5%BD%93%E5%89%8D%E8%A1%8C%E6%95%B0%E5%92%8C%E5%90%8D%E7%A7%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获取类名称 行数 public static String getFunctionName() { StackTraceElement[] sts = Thread.currentThread().getStackTrace(); if (sts == null) { return null; } for (StackTraceElement st : sts) { if (st.isNativeMethod()) { continue; } if (st.getClassName().equals(Thread.class.getName())) { continue; } if (st.getClassName().equals(Logger.class.getName())) { continue; } return &quot;[&quot; + Thread.currentThread().getName() + &quot;(&quot; + Thread.currentThread().getId() + &quot;): &quot; + st.getFileName() + &quot;:&quot; + st.getLineNumber() + &quot;]&quot;; } return null; } 打印超多数字public static void i(String msg) { if (debug) { String message = createMessage(msg); if (message.length() &gt; 4000) { int chunkCount = message.length() / 4000; // integer division for (int i = 0; i &lt;= chunkCount; i++) { int max = 4000 * (i + 1); if (max &gt;= message.length()) { Log.i(tag,message.substring(4000 * i)+&quot;\n&quot;); } else { Log.v(tag, message.substring(4000 * i, max)+&quot;\n&quot;); } } }else { Log.i(tag, message); } } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局域网内 ip连接]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85-ip%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[转载https://blog.csdn.net/jspping/article/details/64438515在当今的互联网时代，很多互联网公司、方案公司、智能设备公司或多或少都会接触一些局域网内的相关开发，比如某公司研发了一个app，该app需求是在局域网和网域网都可以获取自己好友的消息或信息，网域网下技术人员可以通过服务器转接信息和发送，实现交互，但是在非联网的局域网下使用部分非使用网络的功能，这就需要研究一些比较不常用的类，在通常情况下，可能大部分人首先想到的肯定是0-255的逐个去ping，这样效率超级低！而且粗暴的方式还可能导致oom，之前说到的 ping ，就是比如局域网下发射信号的主机即服务器，这里我就形象的说是路由器吧，比如路由器的ip是192.168.0.1，那连接它的其他设备的ip被分配的ip也是192.168.0.xxx，这里的xxx是一个取值范围0-255，很多时候大家为了方便就采用循环来对0-255这样的一个一个的去ping，也就是像192.168.0.2、192.168.0.3……这样一直到255,效率非常慢。。。 所以今天就给大家分享一个好东西，java.net.MulticastSocket MulticastSocket 继承自 DatagramSocket [java] view plain copy/* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.*/ package java.net; import java.io.IOException;import java.util.Enumeration;import libcore.io.IoUtils; /** This class implements a multicast socket for sending and receiving IP multicast datagram packets. @see DatagramSocket*/public class MulticastSocket extends DatagramSocket { /** Stores the address supplied to setInterface so we can return it from getInterface. The translation to an interface index is lossy because an interface can have multiple addresses.*/private InetAddress setAddress; /** Constructs a multicast socket, bound to any available port on the local host. @throws IOException if an error occurs.*/public MulticastSocket() throws IOException { setReuseAddress(true);} /** Constructs a multicast socket, bound to the specified {@code port} on the local host. @throws IOException if an error occurs.*/public MulticastSocket(int port) throws IOException { super(port); setReuseAddress(true);} /** Constructs a {@code MulticastSocket} bound to the address and port specified by {@code localAddress}, or an unbound {@code MulticastSocket} if {@code localAddress == null}. @throws IllegalArgumentException if {@code localAddress} is not supported (because it’s not an {@code InetSocketAddress}, say). @throws IOException if an error occurs.*/public MulticastSocket(SocketAddress localAddress) throws IOException { super(localAddress); setReuseAddress(true);} /** Returns an address of the outgoing network interface used by this socket. To avoid inherent unpredictability, new code should use {@link #getNetworkInterface} instead. @throws SocketException if an error occurs.*/public InetAddress getInterface() throws SocketException { checkOpen(); if (setAddress != null) { return setAddress; } InetAddress ipvXaddress = (InetAddress) impl.getOption(SocketOptions.IP_MULTICAST_IF); if (ipvXaddress.isAnyLocalAddress()) { // the address was not set at the IPv4 level so check the IPv6 // level NetworkInterface theInterface = getNetworkInterface(); if (theInterface != null) { Enumeration&lt;InetAddress&gt; addresses = theInterface.getInetAddresses(); if (addresses != null) { while (addresses.hasMoreElements()) { InetAddress nextAddress = addresses.nextElement(); if (nextAddress instanceof Inet6Address) { return nextAddress; } } } } } return ipvXaddress;} /** Returns the outgoing network interface used by this socket. @throws SocketException if an error occurs.*/public NetworkInterface getNetworkInterface() throws SocketException { checkOpen(); int index = (Integer) impl.getOption(SocketOptions.IP_MULTICAST_IF2); if (index != 0) { return NetworkInterface.getByIndex(index); } return NetworkInterface.forUnboundMulticastSocket();} /** Returns the time-to-live (TTL) for multicast packets sent on this socket. @throws IOException if an error occurs.*/public int getTimeToLive() throws IOException { checkOpen(); return impl.getTimeToLive();} /** Returns the time-to-live (TTL) for multicast packets sent on this socket. @throws IOException if an error occurs. @deprecated Use {@link #getTimeToLive} instead.*/@Deprecatedpublic byte getTTL() throws IOException { checkOpen(); return impl.getTTL();} /** Adds this socket to the specified multicast group. A socket must join a group before data may be received. A socket may be a member of multiple groups but may join any group only once. @param groupAddr the multicast group to be joined. @throws IOException if an error occurs.*/public void joinGroup(InetAddress groupAddr) throws IOException { checkJoinOrLeave(groupAddr); impl.join(groupAddr);} /** Adds this socket to the specified multicast group. A socket must join a group before data may be received. A socket may be a member of multiple groups but may join any group only once. @param groupAddress the multicast group to be joined. @param netInterface the network interface on which the datagram packets will be received. @throws IOException if the specified address is not a multicast address. @throws IllegalArgumentException if no multicast group is specified.*/public void joinGroup(SocketAddress groupAddress, NetworkInterface netInterface) throws IOException {checkJoinOrLeave(groupAddress, netInterface);impl.joinGroup(groupAddress, netInterface);} /** Removes this socket from the specified multicast group. @param groupAddr the multicast group to be left. @throws NullPointerException if {@code groupAddr} is {@code null}. @throws IOException if the specified group address is not a multicast address.*/public void leaveGroup(InetAddress groupAddr) throws IOException {checkJoinOrLeave(groupAddr);impl.leave(groupAddr);} /** Removes this socket from the specified multicast group. @param groupAddress the multicast group to be left. @param netInterface the network interface on which the addresses should be dropped. @throws IOException if the specified group address is not a multicast address. @throws IllegalArgumentException if {@code groupAddress} is {@code null}.*/public void leaveGroup(SocketAddress groupAddress, NetworkInterface netInterface) throws IOException {checkJoinOrLeave(groupAddress, netInterface);impl.leaveGroup(groupAddress, netInterface);} private void checkJoinOrLeave(SocketAddress groupAddress, NetworkInterface netInterface) throws IOException {checkOpen();if (groupAddress == null) {throw new IllegalArgumentException(“groupAddress == null”);} if (netInterface != null &amp;&amp; !netInterface.getInetAddresses().hasMoreElements()) {throw new SocketException(“No address associated with interface: “ + netInterface);} if (!(groupAddress instanceof InetSocketAddress)) {throw new IllegalArgumentException(“Group address not an InetSocketAddress: “ +groupAddress.getClass());} InetAddress groupAddr = ((InetSocketAddress) groupAddress).getAddress();if (groupAddr == null) {throw new SocketException(“Group address has no address: “ + groupAddress);} if (!groupAddr.isMulticastAddress()) {throw new IOException(“Not a multicast group: “ + groupAddr);}} private void checkJoinOrLeave(InetAddress groupAddr) throws IOException {checkOpen();if (groupAddr == null) {throw new IllegalArgumentException(“groupAddress == null”);}if (!groupAddr.isMulticastAddress()) {throw new IOException(“Not a multicast group: “ + groupAddr);}} /** Sends the given {@code packet} on this socket, using the given {@code ttl}. This method is deprecated because it modifies the TTL socket option for this socket twice on each call. @throws IOException if an error occurs. @deprecated Use {@link #setTimeToLive} instead.*/@Deprecatedpublic void send(DatagramPacket packet, byte ttl) throws IOException { checkOpen(); InetAddress packAddr = packet.getAddress(); int currTTL = getTimeToLive(); if (packAddr.isMulticastAddress() &amp;&amp; (byte) currTTL != ttl) { try { setTimeToLive(ttl &amp; 0xff); impl.send(packet); } finally { setTimeToLive(currTTL); } } else { impl.send(packet); }} /** Sets the outgoing network interface used by this socket. The interface used is the first interface found to have the given {@code address}. To avoid inherent unpredictability, new code should use {@link #getNetworkInterface} instead. @throws SocketException if an error occurs.*/public void setInterface(InetAddress address) throws SocketException { checkOpen(); if (address == null) { throw new NullPointerException(&quot;address == null&quot;); } NetworkInterface networkInterface = NetworkInterface.getByInetAddress(address); if (networkInterface == null) { throw new SocketException(&quot;Address not associated with an interface: &quot; + address); } impl.setOption(SocketOptions.IP_MULTICAST_IF2, networkInterface.getIndex()); this.setAddress = address;} /** Sets the outgoing network interface used by this socket to the given {@code networkInterface}. @throws SocketException if an error occurs.*/public void setNetworkInterface(NetworkInterface networkInterface) throws SocketException { checkOpen(); if (networkInterface == null) { throw new SocketException(&quot;networkInterface == null&quot;); } impl.setOption(SocketOptions.IP_MULTICAST_IF2, networkInterface.getIndex()); this.setAddress = null;} /** Sets the time-to-live (TTL) for multicast packets sent on this socket. Valid TTL values are between 0 and 255 inclusive. @throws IOException if an error occurs.*/public void setTimeToLive(int ttl) throws IOException { checkOpen(); if (ttl &lt; 0 || ttl &gt; 255) { throw new IllegalArgumentException(&quot;TimeToLive out of bounds: &quot; + ttl); } impl.setTimeToLive(ttl);} /** Sets the time-to-live (TTL) for multicast packets sent on this socket. Valid TTL values are between 0 and 255 inclusive. @throws IOException if an error occurs. @deprecated Use {@link #setTimeToLive} instead.*/@Deprecatedpublic void setTTL(byte ttl) throws IOException { checkOpen(); impl.setTTL(ttl);} @Overridesynchronized void createSocket(int aPort, InetAddress addr) throws SocketException { impl = factory != null ? factory.createDatagramSocketImpl() : new PlainDatagramSocketImpl(); impl.create(); try { impl.setOption(SocketOptions.SO_REUSEADDR, Boolean.TRUE); impl.bind(aPort, addr); isBound = true; } catch (SocketException e) { close(); throw e; }} /** Returns true if multicast loopback is disabled. See {@link SocketOptions#IP_MULTICAST_LOOP}, and note that the sense of this is the opposite of the underlying Unix {@code IP_MULTICAST_LOOP}. @throws SocketException if an error occurs.*/public boolean getLoopbackMode() throws SocketException { checkOpen(); return !((Boolean) impl.getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();} /** Disables multicast loopback if {@code disable == true}. See {@link SocketOptions#IP_MULTICAST_LOOP}, and note that the sense of this is the opposite of the underlying Unix {@code IP_MULTICAST_LOOP}: true means disabled, false means enabled. @throws SocketException if an error occurs.*/public void setLoopbackMode(boolean disable) throws SocketException { checkOpen(); impl.setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(!disable));}} 了解一下该类后可以开始下面的编程，首先说一下客户端，再说服务端，最后说明使用方法①客户端代码核心： [java] view plain copy@Overrideprotected void onResume() { super.onResume(); /** * @author Engineer-Jsp * 笔者在该 Activity 的 onResume()函数初始化接收的侦听 */ onBrodacastReceiver(); }②onBrodacastReceiver()函数：[java] view plain copyMulticastSocket multicastSocket; /** @author Engineer-Jsp onBrodacastReceiver()*/private void onBrodacastReceiver() { new Thread(new Runnable() { @Override public void run() { try { // 接收数据时需要指定监听的端口号 multicastSocket = new MulticastSocket(10001); // 创建组播ID地址 InetAddress address = InetAddress.getByName(&quot;239.0.0.1&quot;); // 加入地址 multicastSocket.joinGroup(address); // 包长 byte[] buf = new byte[1024]; while (true) { // 数据报 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 接收数据，同样会进入阻塞状态 multicastSocket.receive(datagramPacket); // 从buffer中截取收到的数据 byte[] message = new byte[datagramPacket.getLength()]; // 数组拷贝 System.arraycopy(buf, 0, message, 0, datagramPacket.getLength()); // 打印来自组播里其他服务的or客户端的ip System.out.println(datagramPacket.getAddress()); // 打印来自组播里其他服务的or客户端的消息 System.out.println(new String(message)); // 收到消息后可以进行记录然后二次确认，如果只是想获取ip，在发送方收到该消息后可关闭套接字，从而释放资源 onBrodacastSend(datagramPacket.getAddress()); } } catch (IOException e) { e.printStackTrace(); } } }).start();} ③ onBrodacastSend() 函数[java] view plain copy/** onBrodacastSend() @author Engineer-Jsp @param address ip*/private void onBrodacastSend(InetAddress address) { // 假设 239.0.0.1 已经收到了来自其他组ip段的消息，为了进行二次确认，发送 “snoop” // 进行确认，当发送方收到该消息可以释放资源 String out = “snoop”; // 获取”snoop”的字节数组 byte[] buf = out.getBytes(); // 组报 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 设置地址，该地址来自onBrodacastReceiver()函数阻塞数据报，datagramPacket.getAddress() datagramPacket.setAddress(address); // 发送的端口号 datagramPacket.setPort(8082); try { // 开始发送 multicastSocket.send(datagramPacket); } catch (IOException e) { e.printStackTrace(); }} 这是客户端的代码，下面开始上服务端的代码①初始化 [java] view plain copy@Overrideprotected void onResume() { super.onResume(); /** * @author Engineer-Jsp * 笔者在该 Activity 的 onResume()函数初始化接收和发送 * onBrodacastSend() 发送 * onBrodacastReceiver() 接收 */ onBrodacastSend(); onBrodacastReceiver(); }② onBrodacastSend() 函数[java] view plain copyInetAddress address;MulticastSocket multicastSocket; /** @author Engineer-Jsp onBrodacastSend() 发送*/private void onBrodacastSend() { try { // 侦听的端口 multicastSocket = new MulticastSocket(8082); // 使用D类地址，该地址为发起组播的那个ip段，即侦听10001的套接字 address = InetAddress.getByName(&quot;239.0.0.1&quot;); new Thread(new Runnable() { @Override public void run() { while (true) { // 获取当前时间 String time = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()); // 当前时间+标识后缀 time = time + &quot; &gt;&gt;&gt; form server onBrodacastSend()&quot;; // 获取当前时间+标识后缀的字节数组 byte[] buf = time.getBytes(); // 组报 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 向组播ID，即接收group /239.0.0.1 端口 10001 datagramPacket.setAddress(address); // 发送的端口号 datagramPacket.setPort(10001); try { // 开始发送 multicastSocket.send(datagramPacket); // 每执行一次，线程休眠2s，然后继续下一次任务 Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } }).start(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }} ③onBrodacastReceiver(）函数[java] view plain copy/** @author Engineer-Jsp onBrodacastReceiver() 接收*/private void onBrodacastReceiver() { new Thread(new Runnable() { @Override public void run() { try { // 字节数组的格式，即最大大小 byte[] buf = new byte[1024]; while (true) { // 组报格式 DatagramPacket datagramPacket = new DatagramPacket(buf, buf.length); // 接收来自group组播10001端口的二次确认，阻塞 multicastSocket.receive(datagramPacket); // 从buf中截取收到的数据 byte[] message = new byte[datagramPacket.getLength()]; // 数组拷贝 System.arraycopy(buf, 0, message, 0, datagramPacket.getLength()); // 这里打印ip字段 System.out.println(datagramPacket.getAddress()); // 打印组播端口10001发送过来的消息 System.out.println(new String(message)); // 这里可以根据结接收到的内容进行分发处理，假如收到 10001的 &quot;snoop&quot;字段为关闭命令，即可在此处关闭套接字从而释放资源 } } catch (IOException e) { e.printStackTrace(); } } }).start();} 这是服务端的代码，也分享完了，下面画一个图来大概描述一下他们的工作流程图示意： 使用方法：①首先需要在同一wifi网络下 ②需要获取所有ip的手机安装客户端，即侦听10001的那个端口 ③所有需要将信息共享并组播到 239.0.0.1:10001这个group的安装服务端 ④开启服务端与客户端开始进行数据的交互 以上是大致的描述图，帮助大家理解，谢谢观博！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MulticastSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基本技术点无线设备]]></title>
    <url>%2F2018%2F05%2F24%2FAndroid%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%82%B9%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[无线连接设备 Network Service Discovery:NSD网络服务发现。 WiFi建立P2P连接 使用WiFi P2P服务 NSD网络发现 NsdManager 管理涉及到服务注册、监听器、取消服务等，当业务完成要及时取消注册服务(取消注册、关闭搜索服务)，防止占用资源 registerService注册监听器 resolveService解析监听器 discoverServices搜索可发现服务 NsdServiceInfo注册服务的信息 - setServiceName - setPort - setServiceType 不推荐硬编码设置端口号，建议使用这种： ServerSocket sock = new ServerSocket(0); port = sock.getLocalPort(); sock.close(); 其中的服务类型写法：指定应用使用的协议和传输层。语法是“_&lt; protocol &gt;._&lt; transportlayer &gt;” NsdManager.DiscoveryListener mDiscoveryListener = new NsdManager.DiscoveryListener() { // Called as soon as service discovery begins. @Override public void onDiscoveryStarted(String regType) { Log.d(TAG, &quot;Service discovery started&quot;); } @Override public void onServiceFound(NsdServiceInfo service) { // A service was found! Do something with it. Log.d(TAG, &quot;Service discovery success&quot; + service); if (!service.getServiceType().equals(&quot;_http._tcp.&quot;)) { // Service type is the string containing the protocol and // transport layer for this service. Log.d(TAG, &quot;Unknown Service Type: &quot; + service.getServiceType()); } else if (service.getServiceName().equals(mServiceName)) { // The name of the service tells the user what they&apos;d be // connecting to. It could be &quot;Bob&apos;s Chat App&quot;. Log.d(TAG, &quot;Same machine: &quot; + mServiceName); } else if (service.getServiceName().contains(&quot;NsdChat&quot;)){ mNsdManager.resolveService(service, mResolveListener); } } @Override public void onServiceLost(NsdServiceInfo service) { // When the network service is no longer available. // Internal bookkeeping code goes here. Log.e(TAG, &quot;service lost&quot; + service); } @Override public void onDiscoveryStopped(String serviceType) { Log.i(TAG, &quot;Discovery stopped: &quot; + serviceType); } @Override public void onStartDiscoveryFailed(String serviceType, int errorCode) { Log.e(TAG, &quot;Discovery failed: Error code:&quot; + errorCode); mNsdManager.stopServiceDiscovery(this); } @Override public void onStopDiscoveryFailed(String serviceType, int errorCode) { Log.e(TAG, &quot;Discovery failed: Error code:&quot; + errorCode); mNsdManager.stopServiceDiscovery(this); } }; NsdManager.RegistrationListener mRegistrationListener = new NsdManager.RegistrationListener() { @Override public void onServiceRegistered(NsdServiceInfo NsdServiceInfo) { // Save the service name. Android may have changed it in order to // resolve a conflict, so update the name you initially requested // with the name Android actually used. mServiceName = NsdServiceInfo.getServiceName(); } @Override public void onRegistrationFailed(NsdServiceInfo serviceInfo, int errorCode) { // Registration failed! Put debugging code here to determine why. } @Override public void onServiceUnregistered(NsdServiceInfo arg0) { // Service has been unregistered. This only happens when you call // NsdManager.unregisterService() and pass in this listener. } @Override public void onUnregistrationFailed(NsdServiceInfo serviceInfo, int errorCode) { // Unregistration failed. Put debugging code here to determine why. } }; NsdManager.ResolveListener mResolveListener = new NsdManager.ResolveListener() { @Override public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) { // Called when the resolve fails. Use the error code to debug. Log.e(TAG, &quot;Resolve failed&quot; + errorCode); } @Override public void onServiceResolved(NsdServiceInfo serviceInfo) { Log.e(TAG, &quot;Resolve Succeeded. &quot; + serviceInfo); if (serviceInfo.getServiceName().equals(mServiceName)) { Log.d(TAG, &quot;Same IP.&quot;); return; } } }; 大致流程：注册本机服务 -&gt; 注册监听 -&gt; 注解解析 -&gt; 搜索发现服务 -&gt; 解析可发现的 -&gt; 获取ip 端口号 -&gt; 连接 WiFi p2p连接 p2p不需要访问网络，但是会使用java中的socket，socket需网络权限( CHANGE_WIFI_STATE、ACCESS_WIFI_STATE、INTERNET) 设置广播接收器和p2p管理器 首先注册广播，监听每次的wifi p2p事件变化，主要监听WIFI_P2P_STATE_CHANGED_ACTION Wi-Fi P2P 是否开启，WIFI_P2P_PEERS_CHANGED_ACTION 对等节点（peer）列表发生了变化,WIFI_P2P_CONNECTION_CHANGED_ACTION 连接状态发生了改变,WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 设备的详细配置发生了变化这些广播，这些广播定义在WifiP2pManager类中。 实例化Channel对象，在后续的方法中基本都需要用到，WifiP2pManager的方法基本都需要这个，应该是传递数据封装数据用的。 mChannel = mManager.initialize(this, getMainLooper(), null); 初始化对等节点发现（Peer Discovery） discoverPeers() 搜索设备 基本概念 WPS是啥？？？？： （Wi-Fi Protected Setup，Wi-Fi保护设置）（有的叫做AOSS、有的叫做QSS，不过功能都一致。）是由Wi-Fi联盟组织实施的认证项目，主要致力于简化无线局域网的安装及安全性能配置工作。在传统方式下，用户新建一个无线网络时，必须在接入点手动设置网络名（SSID）和安全密钥，然后在客户端验证密钥以阻止“不速之客”的闯入。这整个过程需要用户具备Wi-Fi设备的背景知识和修改必要配置的能力。Wi- Fi Protected Setup能帮助用户自动设置网络名（SSID）、配置强大的WPA数据编码及认证功能，用户只需输入个人信息码（PIN方法）或按下按钮（按钮设置，或称PBC），即能安全地连入WLAN。这大大简化了无线安全设置的操作。Wi-Fi Protected Setup支持多种通过Wi-Fi认证的802.11产品，包括接入点、无线适配器、Wi-Fi电话以及其他消费性电子设备。 WPS分为PBC(BUTTON)和PIN两种方式： A PBC: 按WPS按钮实现WPS安全连接. 在AP中，在WPS设置中,设置为启用. 按一下客户端(无线网卡)上的WPS按键,搜索WPS网络. 按一下AP上的WPS按键,WPS开始链接协商,片刻后WPS安全连接成功建立. B PIN B1) PIN(Internal Registra, 相对于AP而言)：通过在路由器中输入客户端PIN码来实现WPS安全连接. 在WPS设置中,把状态设置为启用. 打开客户端WPS设置软件,选择在路由器中输入PIN的方式连接,同时软件上还会显示客户端当前的PIN码. 打开路由器界面,在WPS模式里选择PIN模式,然后输入客户端的PIN码,点添加新设备,一会儿后,WPS安全连接成功建立. B2) PIN(External Registra, 相对于AP而言)：通过输入AP的PIN码实现WPS安全连接.在AP中，在WPS设置中,设置为启用. 记住AP的PIN码,然后打开客户端（无线网卡）WPS设置软件,选择以AP的PIN码来进行连接. 输入完PIN码后,点下一步,一会儿后,WPS安全连接成功建立. 代码 public class WifiP2PActivity extends AppCompatActivity { String TAG = &quot; WifiP2P&quot;; WifiP2pManager mWifiP2pManager; Channel mChannel; IntentFilter mIntentFilter; WifiP2PBReciver mReciver; List&lt;WifiP2pDevice&gt; peers = new ArrayList(); WifiP2pConfig mWifiP2pConfig; //获取设备列表 private WifiP2pManager.PeerListListener peerListListener = new WifiP2pManager.PeerListListener() { @Override public void onPeersAvailable(WifiP2pDeviceList peerList) { // 获取设备列表 peerList.getDeviceList(); Log.i(TAG,&quot;获取的对等节点列表：&quot;+peerList.toString()); peers.clear(); peers.addAll(peerList.getDeviceList()); // 连接 不应该在这写，这是动态变化的，应该手动选择时从保存的对等节点列表中获取信息，去连接 mWifiP2pConfig = new WifiP2pConfig(); mWifiP2pConfig.deviceAddress = peers.get(0).deviceAddress; mWifiP2pConfig.wps.setup = WpsInfo.PBC; mWifiP2pManager.connect(mChannel, mWifiP2pConfig, new WifiP2pManager.ActionListener() { @Override public void onSuccess() { Log.i(TAG,&quot;连接成功了&quot;); } @Override public void onFailure(int reason) { Log.i(TAG,&quot;连接失败了:&quot;+reason); } }); } }; WifiP2pManager.ConnectionInfoListener connectionInfoListener = new WifiP2pManager.ConnectionInfoListener() { @Override public void onConnectionInfoAvailable(WifiP2pInfo info) { // InetAddress from WifiP2pInfo struct. //当有多个设备同时试图连接到一台设备时（例如多人游戏或者聊天群），这一台设备将被指定为“群主”（group owner）。 String groupOwnerAddress = info.groupOwnerAddress.getHostAddress(); // After the group negotiation, we can determine the group owner. if (info.groupFormed &amp;&amp; info.isGroupOwner) { // Do whatever tasks are specific to the group owner. // One common case is creating a server thread and accepting // incoming connections. } else if (info.groupFormed) { // The other device acts as the client. In this case, // you&apos;ll want to create a client thread that connects to the group // owner. } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_wifi_p2_p); mIntentFilter = new IntentFilter(); //连接状态发生了改变 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION); // 指示设备的详细配置发生了变化 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION); //代表对等节点（peer）列表发生了变化 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION); // 指示 Wi-Fi P2P 是否开启 mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION); mWifiP2pManager = (WifiP2pManager) getApplicationContext().getSystemService(WIFI_P2P_SERVICE); mChannel = mWifiP2pManager.initialize(this, getMainLooper(), new WifiP2pManager.ChannelListener() { @Override public void onChannelDisconnected() { Log.i(TAG,&quot;通道断开&quot;); } }); //搜索对等节点 peers mWifiP2pManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() { @Override public void onSuccess() { Log.i(TAG,&quot;搜索成功！&quot;); } @Override public void onFailure(int reason) { //WifiP2pManager 中的失败值 /*** Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the operation failed due to an internal error. */int ERROR = 0; /** * Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the operation failed because p2p is unsupported on the device. */int P2P_UNSUPPORTED = 1; /** * Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the operation failed because the framework is busy and * unable to service the request */int BUSY = 2; /** * Passed with {@link WifiP2pManager.ActionListener#onFailure}. * Indicates that the {@link #discoverServices} failed because no service * requests are added. Use {@link #addServiceRequest} to add a service * request. */int NO_SERVICE_REQUESTS = 3; Log.e(TAG,&quot;搜索失败！&quot;+reason); } }); } @Override protected void onResume() { super.onResume(); //注册接受wifi p2p 状态变化广播 mReciver = new WifiP2PBReciver(); getApplicationContext().registerReceiver(mReciver,mIntentFilter); } @Override protected void onPause() { super.onPause(); try{ unregisterReceiver(mReciver); }catch (Exception e){ } } class WifiP2PBReciver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) { // Determine if Wifi P2P mode is enabled or not, alert // the Activity. int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1); if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) { } else { } } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) { // The peer list has changed! We should probably do something about // that. //在此处获取设备列表变化后的数据 mWifiP2pManager.requestPeers(mChannel,peerListListener); } else if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) { // Connection state changed! We should probably do something about // that. NetworkInfo networkInfo = (NetworkInfo) intent .getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO); if (networkInfo.isConnected()) { // We are connected with the other device, request connection // info to find group owner IP mWifiP2pManager.requestConnectionInfo(mChannel, connectionInfoListener); } } else if (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION.equals(action)) { WifiP2pDevice device = (WifiP2pDevice) intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE); } } } } WiFi P2P 服务发现 首先在本地注册一个服务，服务注册是要将服务类型、服务信息封装到WifiP2pServiceInfo中，再通过WifiP2pManager将服务添加到本地，本地服务添加后注册监听DnsSdTxtRecordListener来实时监听record记录数据，注册DnsSdServiceResponseListener接收服务的实际描述和连接的信息，前者处理记录连接的服务信息用来跟后者做对应关系处理。前者给你一组对他的服务的描述信息，然后在后者进行匹配，将描述信息与实际的硬件信息做匹配，把处理过的数据给用户看。连接后创建服务请求 addServiceRequest()，最后调用 discoverServices() WifiP2pManager(添加服务到本地) wifiP2pManager = (WifiP2pManager) getApplicationContext().getSystemService(WIFI_P2P_SERVICE); WifiP2pServiceInfo (创建本地服务的参数配置信息) WifiP2pDnsSdServiceInfo.newInstance(&quot;instanceName&quot;,&quot;serviceType&quot;,map); serviceType与NSD中的服务类型相同; 服务信息是通过存放在map方式存入，他人连接能够获取到该数据;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>网络发现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的四种引用]]></title>
    <url>%2F2018%2F05%2F24%2Fva%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[强引用 StrongReference强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 ps：强引用其实也就是我们平时A a = new A()这个意思。 弱引用 WeakReference 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 软引用 SoftReference 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 虚引用 PhantomReference “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 ReferenceQueue queue = new ReferenceQueue (); PhantomReference pr = new PhantomReference (object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 场景使用软引用构建敏感数据的缓存 1 为什么需要使用软引用 首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。 2 如果使用软引用 SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。 看下面代码: MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。 随即，我们可以结束aReference对这个MyObject实例的强引用: aRef = null; 此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过: MyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。 3 使用ReferenceQueue清除失去了软引用对象的SoftReference 作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如: ReferenceQueue queue = new ReferenceQueue(); SoftReferenceref=new SoftReference(aMyObject, queue); 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。 在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为: SoftReference ref = null; while ((ref = (EmployeeRef) q.poll()) != null) { // 清除ref } 抄自—&gt;Java四种引用包括强引用，软引用，弱引用，虚引用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到的几个Android学习网站]]></title>
    <url>%2F2018%2F05%2F24%2F%E7%9A%84%E5%87%A0%E4%B8%AAAndroid%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Android Studio使用相关的资料 查看文档之类的 应用的基本概念 gradle学习资料 中文Android学习资料网站大全]]></content>
      <categories>
        <category>学习网站</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记03]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%2F</url>
    <content type="text"><![CDATA[git基本操作符 init git init [-q | --quiet] [--bare] [--template=&lt;template_directory&gt;] [--separate-git-dir &lt;git dir&gt;] [--shared[=&lt;permissions&gt;]] [directory] add git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--chmod=(+|-)x] [--] [&lt;pathspec&gt;…​] 新文件创建，添加到git版本索引库中，加到暂存区，add操作要在commit之前使用。git add -f选项添加被忽略的文件。 $ git add . # 将所有修改添加到暂存区 $ git add * # Ant风格添加修改 $ git add *Controller # 将以Controller结尾的文件的所有修改添加到暂存区 clone git clone [--template=&lt;template_directory&gt;] [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror] [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;] [--dissociate] [--separate-git-dir &lt;git dir&gt;] [--depth &lt;depth&gt;] [--[no-]single-branch] [--recurse-submodules] [--[no-]shallow-submodules] [--jobs &lt;n&gt;] [--] &lt;repository&gt; [&lt;directory&gt;] status git status [&lt;options&gt;…​] [--] [&lt;pathspec&gt;…​] tracked文件被监控文件，untracked文件为要被忽略的文件，不需要提交，在.gitignore文件中加入要忽略的文件通配符；通过git status -uno可以只列出所有已经被git管理的且被修改但没提交的文件 diff git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​] git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​] git diff [options] &lt;blob&gt; &lt;blob&gt; git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt; commit git commit [-a | –interactive | –patch] [-s] [-v] [-u] [–amend] [--dry-run] [(-c | -C | --fixup | --squash) &lt;commit&gt;] [-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author=&lt;author&gt;] [--date=&lt;date&gt;] [--cleanup=&lt;mode&gt;] [--[no-]status] [-i | -o] [-S[&lt;keyid&gt;]] [--] [&lt;file&gt;…​] $ git add . $ # 或者~ $ git add newfile.txt $ git commit -m &quot;the commit message&quot; # $ git commit -a # 会先把所有已经track的文件的改动`git add`进来，然后提交(有点像svn的一次提交,不用先暂存)。对于没有track的文件,还是需要执行`git add &lt;file&gt;` 命令。 $ git commit --amend # 增补提交，会使用与当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>pull</tag>
        <tag>commit</tag>
        <tag>status</tag>
        <tag>init</tag>
        <tag>clone</tag>
        <tag>reset</tag>
        <tag>merge</tag>
        <tag>add</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记02]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%2F</url>
    <content type="text"><![CDATA[git的流程创建仓库 -&gt; 初始化仓库 -&gt; 初始化项目 -&gt; 个人拉取项目到本地 -&gt; 本地文件添加 -&gt; 本地文件修改 -&gt; 提交 -&gt; 差异合并 -&gt; 更新 -&gt; 合并 -&gt; 提交 -&gt; 推送 head代表的是分支]]></content>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记01]]></title>
    <url>%2F2018%2F05%2F23%2Ft%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[基础的知识点 基础 git保存所有的文件的快照的索引，而非对比数据的差异；操作大多数是在本地执行； 三种状态：已提交committed、已修改modified、已暂存staged 基本工作流程 本地工作目录修改文件 将文件快照存放在暂存区域 提交更新，找到暂存区快照，将快照永久存在git仓库目录 大致的流程 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 配置 配置文件git config配置git外观和行为的配置变量，在linux下有三个位置：/etc/gitconfig,~/.gitconfig 或 ~/.config/git/config,当前使用仓库的 Git 目录中的 config;在windows系统下：$HOME目录(C:\Users\$USER)的 .gitconfig),git安装目录下的gitconfig文件; 配置用户信息 $ git config --global user.name &quot;maxsu&quot; $ git config --global user.email maxsu@yiibai.com 文本编辑器 $ git config --global core.editor emacs 如果不习惯使用vim就使用该方法替换掉； 获取配置信息 git config --list]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree]]></title>
    <url>%2F2018%2F05%2F23%2FourceTree%2F</url>
    <content type="text"><![CDATA[git的图形化工具，只支持mac和windows 跳过账号登录在用户本地文件夹下的 SourceTree 目录下，找到accounts.json文件 没有就创建复制一下内容： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot;&quot;, &quot;Email&quot;: null }, &quot;IsDefault&quot;: false } ]]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown编辑器]]></title>
    <url>%2F2018%2F05%2F22%2Fmarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[小书匠 下载地址能够将数据保存到github、云存贮等；]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[既然是程序员，第一个文章当然就是一个：HELLO WORLD!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android中的设计模式]]></title>
    <url>%2F2018%2F05%2F21%2FAndroid%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[（1）单例模式： 简介：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 示例：Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗。 比如LayoutInflater Service，将这些服务以键值对的形式存储在一个HashMap容器中，用户使用时只需要根据key来获取到对应的ServiceFetcher，然后通过ServcieFetcher对象的getService函数来获取到具体的服务对象，第一次获取时会调用ServcieFetcher的createService函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。（2）抽象工厂模式： 简介：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 示例：Android底层对MediaPlayer的创建。MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。（3）工厂模式： 简介：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。（4）原型模式： 简介：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 示例：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。（5）建造者模式： 简介：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 示例：AlertDialog.Builder ImageLoader的初始配置。（6）适配器模式： 简介：将一个类的接口转换成客户希望的另外一个接口。 示例：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。 ListView或GridView的Adapter。（7）桥接模式： 简介：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 示例：Window和WindowManager之间的关系。 在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。（8）装饰模式： 简介：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。（9）组合模式： 简介：将对象组合成树形结构以表示“部分-整体”的层次结构。 示例：View和ViewGroup的组合（10）外观模式 简介：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。 示例：ContextImpl（11）享元模式： 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。（12）代理模式： 简介：为其他对象提供一个代理以控制对这个对象的访问。 示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。（13）观察者模式： 简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。 示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。（14）中介者模式： 简介：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 示例：Binder机制。(15)访问者模式: 简介：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。（16） 解释器模式： 简介：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程，（17）迭代器模式 简介：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。（18）备忘录模式 简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。（19）责任链模式 简介：有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 示例: 责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。（20）状态模式： 简介：状态发生改变时，行为改变。 示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。（21）策略模式 简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。 示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。（22）命令模式 简介：把请求封装成一个对象发送出去，方便定制、排队、取消。 示例：Handler.post后Handler.handleMessage。（23）享元模式 简介：运用共享技术有效地支持大量细粒度的对象。 示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块模式设计]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[什么是设计模式 定义基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。 开闭原则：对修改封闭，对扩展放开。 里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。 接口隔离原则：将大接口改成多个小接口。 迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。 分类设计模式分为三种类型：创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。（口诀：单原建造者，东西二厂） 结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。（口诀：一器一桥一元一代理；装饰组合外观） 行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。（口诀：三者两器、一录一链一模板，状态策略命令） 功能模块设计原则 单一职责原则（Single Responsibility Principle - SRP）原文：There should never be more than one reason for a class to change. 译文：永远不应该有多于一个原因来改变某个类。 理解：对于一个类而言，应该仅有一个引起它变化的原因。说白了就是，不同的类具备不同的职责，各施其责。这就好比一个团队，大家分工协作，互不影响，各做各的事情。 应用：当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！ 开放封闭原则（Open Closed Principle - OCP）原文：Software entities like classes, modules and functions should be open for extension but closed for modifications. 译文：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。 理解：简言之，对扩展开放，对修改封闭。换句话说，可以去扩展类，但不要去修改类。 应用：当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。 里氏替换原则（Liskov Substitution Principle - LSP）原文：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 译文：使用基类的指针或引用的函数，必须是在不知情的情况下，能够使用派生类的对象。 理解：父类能够替换子类，但子类不一定能替换父类。也就是说，在代码中可以将父类全部替换为子类，程序不会报错，也不会在运行时出现任何异常，但反过来却不一定成立。 应用：在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），子类尽量不要暴露自己的 public 方法供外界调用。 最少知识原则（Least Knowledge Principle - LKP）原文：Only talk to you immediate friends. 译文：只与你最直接的朋友交流。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。 应用：在做系统设计时，不要让一个类依赖于太多的其他类，需尽量减小依赖关系，否则，您死都不知道自己怎么死的。 接口隔离原则（Interface Segregation Principle - ISP）原文：The dependency of one class to another one should depend on the smallest possible interface. 译文：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。、理解：不要对外暴露没有实际意义的接口。也就是说，接口是给别人调用的，那就不要去为难别人了，尽可能保证接口的实用性吧。她好，我也好。 应用：当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，就意味着，您将来要多做一件事情，何苦要给自己找事做呢。 依赖倒置原则（Dependence Inversion Principle - DIP）原文：High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 译文：高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 理解：应该面向接口编程，不应该面向实现类编程。面向实现类编程，相当于就是论事，那是正向依赖（正常人思维）；面向接口编程，相当于通过事物表象来看本质，那是反向依赖，即依赖倒置（程序员思维）。 应用：并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧。 ------&gt;------&gt;------&gt;------&gt;------&gt;------&gt;------&gt; 将以上六大原则的英文首字母拼在一起就是 SOLID（稳定的），所以也称之为 SOLID 原则。只有满足了这六大原则，才能设计出稳定的软件架构！但它们毕竟只是原则，只是四人帮给我们的建议，有些时候我们还是要学会灵活应变，千万不要生搬硬套，否则只会把简单问题复杂化 补充设计原则 组合/聚合复用原则（Composition/Aggregation Reuse Principle - CARP）当要扩展类的功能时，优先考虑使用组合，而不是继承。这条原则在 23 种经典设计模式中频繁使用，如：代理模式、装饰模式、适配器模式等。可见江湖地位非常之高！ 无环依赖原则（Acyclic Dependencies Principle - ADP）当 A 模块依赖于 B 模块，B 模块依赖于 C 模块，C 依赖于 A 模块，此时将出现循环依赖。在设计中应该避免这个问题，可通过引入“中介者模式”解决该问题。 共同封装原则（Common Closure Principle - CCP）应该将易变的类放在同一个包里，将变化隔离出来。该原则是“开放-封闭原则”的延生。 共同重用原则（Common Reuse Principle - CRP）如果重用了包中的一个类，那么也就相当于重用了包中的所有类，我们要尽可能减小包的大小。 好莱坞原则（Hollywood Principle - HP）好莱坞明星的经纪人一般都很忙，他们不想被打扰，往往会说：Don&apos;t call me, I&apos;ll call you. 翻译为：不要联系我，我会联系你。对应于软件设计而言，最著名的就是“控制反转”（或称为“依赖注入”），我们不需要在代码中主动的创建对象，而是由容器帮我们来创建并管理这些对象。 其它设计原则 不要重复你自己（Don’t repeat yourself - DRY）不要让重复的代码到处都是，要让它们足够的重用，所以要尽可能地封装。 保持它简单与傻瓜（Keep it simple and stupid - KISS）不要让系统变得复杂，界面简洁，功能实用，操作方便，要让它足够的简单，足够的傻瓜。 高内聚与低耦合（High Cohesion and Low Coupling - HCLC）模块内部需要做到内聚度高，模块之间需要做到耦合度低。 惯例优于配置（Convention over Configuration - COC）尽量让惯例来减少配置，这样才能提高开发效率，尽量做到“零配置”。很多开发框架都是这样做的。 命令查询分离（Command Query Separation - CQS）在定义接口时，要做到哪些是命令，哪些是查询，要将它们分离，而不要揉到一起。 关注点分离（Separation of Concerns - SOC）将一个复杂的问题分离为多个简单的问题，然后逐个解决这些简单的问题，那么这个复杂的问题就解决了。难就难在如何进行分离。 契约式设计（Design by Contract - DBC）模块或系统之间的交互，都是基于契约（接口或抽象）的，而不要依赖于具体实现。该原则建议我们要面向契约编程。 你不需要它（You aren’t gonna need it - YAGNI）不要一开始就把系统设计得非常复杂，不要陷入“过度设计”的深渊。应该让系统足够的简单，而却又不失扩展性，这是其中的难点。]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F05%2F21%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[java反射实现方式 实例化要反射的Class对象Class.forName(类名全路径); //通过Class的静态方法；对象.getClass() //通过对象.getClass方法；int.class //基本数据类型及基本数据类型的封装了，例如Integer； 获取父类Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Class&lt;?&gt; superclass = clazz.getSuperclass(); 获取实现接口Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Class&lt;?&gt;[] interfaces = clazz.getInterfaces() 获取指定参数构造函数及实例化Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法Constructor&lt;?&gt; constructor = clazz.getConstructor(Class&lt;?&gt; ... class);//获取公共的 Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor()//获取私有的 constructor.newInstance(Object args); 获取所有构造函数及构造参数的类型Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors();//公共的 Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors()//包括私有的 for (int i = 0; i &lt; constructors.length; i++) { Class&lt;?&gt; clazzs[] = constructors[i].getParameterTypes();//获取类型 System.out.print(&quot;constructors[&quot; + i + &quot;] (&quot;); for (int j = 0; j &lt; clazzs.length; j++) { if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + &quot;,&quot;); } System.out.println(&quot;)&quot;); } 通过无参实例化对象Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 class.newInstance(); 获取字段，修改字段Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Field field = clazz.getField(String name);//获取公共字段 Field field = clazz.getDeclaredField(String name);//获取私有公共字段 Field[] field = clazz.getFields();//获取所有公共字段 Field[] field = clazz.getDeclaredFields();//获取包括私有所有字段 Field field = clazz.getDeclaredField(&quot;heihei&quot;); field.setAccessible(true);//设置java取消访问检查，也就是说如果是私有的也可以访问, field.set(obj, &quot;Java反射机制&quot;); 获取方法,运行方法Class&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 clazz.getMethod(String name ,Class&lt;?&gt; ... parame);//获取公共指定方法 clazz.getDeclaredMethod(String name ,Class&lt;?&gt; ... parame)//获取私有指定方法 clazz.getMethods()//获取公共所有方法 clazz.getDeclaredMethods();//获取包括私有全部方法 Method method = clazz.getMethod(&quot;add&quot;); method.invoke(clazz.newInstance()); method = clazz.getMethod(&quot;getInfo&quot;, int.class, String.class); method.setAccessible(true)//设置java取消访问检查，也就是说如果是私有的也可以访问, method.invoke(clazz.newInstance(), 20, &quot;张三&quot;); 获取数组或者list中的类型,如果不是数组或集合返回nullClass&lt;?&gt; clazz = Class.forName(类名全路径); //通过Class的静态方法 Class&lt;?&gt; componentType = clazz.getComponentType();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妞妞照片]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%A6%9E%E5%A6%9E%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>照片</category>
      </categories>
      <tags>
        <tag>妞妞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的妞妞]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%88%91%E7%9A%84%E5%A6%9E%E5%A6%9E%2F</url>
    <content type="text"><![CDATA[我的妞妞长的好看！！！美！！！]]></content>
      <tags>
        <tag>妞妞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜园子博客开始的地方]]></title>
    <url>%2F2018%2F05%2F21%2Fpost%2F</url>
    <content type="text"><![CDATA[打今天开始打理自己菜园子，菜园子有三块地，笔记、生活照片、记事本没啥说的，希望能够坚持下去，早点给自己定个目标吧。]]></content>
      <tags>
        <tag>给自己</tag>
      </tags>
  </entry>
</search>
