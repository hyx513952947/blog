<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/猴猴.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/猴猴.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/猴猴.png?v=5.1.4">


  <link rel="mask-icon" href="/images/猴猴.png?v=5.1.4" color="#222">





  <meta name="keywords" content="大帅" />










<meta name="description" content="1.java面向对象编程    三大特性：        封装、继承、多态；    栈内存、堆内存：        基本类型的变量和对象的引用变量都在函数的栈内存中分配；堆内存存放new创建的对象和数组； 1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与    C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 2. 栈的优势是，存取速度比堆要快，仅">
<meta property="og:type" content="article">
<meta property="og:title" content="笼统的资料">
<meta property="og:url" content="http://www.huangguaniu.top/2018/06/27/统的资料/index.html">
<meta property="og:site_name" content="菜园子">
<meta property="og:description" content="1.java面向对象编程    三大特性：        封装、继承、多态；    栈内存、堆内存：        基本类型的变量和对象的引用变量都在函数的栈内存中分配；堆内存存放new创建的对象和数组； 1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与    C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 2. 栈的优势是，存取速度比堆要快，仅">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-27T08:18:00.564Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笼统的资料">
<meta name="twitter:description" content="1.java面向对象编程    三大特性：        封装、继承、多态；    栈内存、堆内存：        基本类型的变量和对象的引用变量都在函数的栈内存中分配；堆内存存放new创建的对象和数组； 1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与    C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 2. 栈的优势是，存取速度比堆要快，仅">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":20,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":8},
      labels: {"input_placeholder":"搜索结果","hits_empty":"没有找到相关内容: ${query}","hits_stats":"在 ${time} ms内找到 ${hits} 条结果"}
    }
  };
</script>



  <link rel="canonical" href="http://www.huangguaniu.top/2018/06/27/统的资料/"/>





  <title>笼统的资料 | 菜园子</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜园子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">我的菜园子</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.huangguaniu.top/2018/06/27/统的资料/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大帅">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜园子">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">笼统的资料</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T16:14:15+08:00">
                2018-06-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-06-27T16:18:00+08:00">
                2018-06-27
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12,687个字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  47分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>1.java面向对象编程<br>    三大特性：<br>        封装、继承、多态；<br>    栈内存、堆内存：<br>        基本类型的变量和对象的引用变量都在函数的栈内存中分配；堆内存存放new创建的对象和数组；</p>
<pre><code>1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与    C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。
2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
3. Java中的数据类型有两种。 一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知()，出于追求速度的原因，就存在于栈中。
</code></pre><p>2.软件功能模块设计（与设计模式相互补充 4.1）</p>
<pre><code>1. 单一职责原则（Single Responsibility Principle - SRP）
    原文：There should never be more than one reason for a class to change.
    译文：永远不应该有多于一个原因来改变某个类。
    理解：对于一个类而言，应该仅有一个引起它变化的原因。说白了就是，不同的类具备不同的职责，各施其责。这就好比一个团队，大家分工协作，互不影响，各做各的事情。
    应用：当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！
2. 开放封闭原则（Open Closed Principle - OCP）
    原文：Software entities like classes, modules and functions should be open for extension but closed for modifications.
    译文：软件实体，如：类、模块与函数，对于扩展应该是开放的，但对于修改应该是封闭的。
    理解：简言之，对扩展开放，对修改封闭。换句话说，可以去扩展类，但不要去修改类。
    应用：当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。
3. 里氏替换原则（Liskov Substitution Principle - LSP）
    原文：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
    译文：使用基类的指针或引用的函数，必须是在不知情的情况下，能够使用派生类的对象。
    理解：父类能够替换子类，但子类不一定能替换父类。也就是说，在代码中可以将父类全部替换为子类，程序不会报错，也不会在运行时出现任何异常，但反过来却不一定成立。
    应用：在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），子类尽量不要暴露自己的 public 方法供外界调用。
4. 最少知识原则（Least Knowledge Principle - LKP）
    原文：Only talk to you immediate friends.
    译文：只与你最直接的朋友交流。
    理解：尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。
    应用：在做系统设计时，不要让一个类依赖于太多的其他类，需尽量减小依赖关系，否则，您死都不知道自己怎么死的。
5. 接口隔离原则（Interface Segregation Principle - ISP）
    原文：The dependency of one class to another one should depend on the smallest possible interface.
    译文：一个类与另一个类之间的依赖性，应该依赖于尽可能小的接口。、理解：不要对外暴露没有实际意义的接口。也就是说，接口是给别人调用的，那就不要去为难别人了，尽可能保证接口的实用性吧。她好，我也好。
    应用：当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，就意味着，您将来要多做一件事情，何苦要给自己找事做呢。
6. 依赖倒置原则（Dependence Inversion Principle - DIP）
    原文：High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.
    译文：高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
    理解：应该面向接口编程，不应该面向实现类编程。面向实现类编程，相当于就是论事，那是正向依赖（正常人思维）；面向接口编程，相当于通过事物表象来看本质，那是反向依赖，即依赖倒置（程序员思维）。
    应用：并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧。
    ------&gt;------&gt;------&gt;------&gt;------&gt;------&gt;------&gt;
    将以上六大原则的英文首字母拼在一起就是 SOLID（稳定的），所以也称之为 SOLID 原则。只有满足了这六大原则，才能设计出稳定的软件架构！但它们毕竟只是原则，只是四人帮给我们的建议，有些时候我们还是要学会灵活应变，千万不要生搬硬套，否则只会把简单问题复杂化
补充设计原则
    1. 组合/聚合复用原则（Composition/Aggregation Reuse Principle - CARP）
        当要扩展类的功能时，优先考虑使用组合，而不是继承。这条原则在 23 种经典设计模式中频繁使用，如：代理模式、装饰模式、适配器模式等。可见江湖地位非常之高！
    2. 无环依赖原则（Acyclic Dependencies Principle - ADP）
        当 A 模块依赖于 B 模块，B 模块依赖于 C 模块，C 依赖于 A 模块，此时将出现循环依赖。在设计中应该避免这个问题，可通过引入“中介者模式”解决该问题。
    3. 共同封装原则（Common Closure Principle - CCP）
        应该将易变的类放在同一个包里，将变化隔离出来。该原则是“开放-封闭原则”的延生。
    4. 共同重用原则（Common Reuse Principle - CRP）
        如果重用了包中的一个类，那么也就相当于重用了包中的所有类，我们要尽可能减小包的大小。
    5. 好莱坞原则（Hollywood Principle - HP）
        好莱坞明星的经纪人一般都很忙，他们不想被打扰，往往会说：Don&apos;t call me, I&apos;ll call you. 翻译为：不要联系我，我会联系你。对应于软件设计而言，最著名的就是“控制反转”（或称为“依赖注入”），我们不需要在代码中主动的创建对象，而是由容器帮我们来创建并管理这些对象。
其它设计原则
    1. 不要重复你自己（Don&apos;t repeat yourself - DRY）
        不要让重复的代码到处都是，要让它们足够的重用，所以要尽可能地封装。
    2. 保持它简单与傻瓜（Keep it simple and stupid - KISS）
        不要让系统变得复杂，界面简洁，功能实用，操作方便，要让它足够的简单，足够的傻瓜。
    3. 高内聚与低耦合（High Cohesion and Low Coupling - HCLC）
        模块内部需要做到内聚度高，模块之间需要做到耦合度低。
    4. 惯例优于配置（Convention over Configuration - COC）
        尽量让惯例来减少配置，这样才能提高开发效率，尽量做到“零配置”。很多开发框架都是这样做的。
    5. 命令查询分离（Command Query Separation - CQS）
        在定义接口时，要做到哪些是命令，哪些是查询，要将它们分离，而不要揉到一起。
    6. 关注点分离（Separation of Concerns - SOC）
        将一个复杂的问题分离为多个简单的问题，然后逐个解决这些简单的问题，那么这个复杂的问题就解决了。难就难在如何进行分离。
    7. 契约式设计（Design by Contract - DBC）
        模块或系统之间的交互，都是基于契约（接口或抽象）的，而不要依赖于具体实现。该原则建议我们要面向契约编程。
    8. 你不需要它（You aren&apos;t gonna need it - YAGNI）
        不要一开始就把系统设计得非常复杂，不要陷入“过度设计”的深渊。应该让系统足够的简单，而却又不失扩展性，这是其中的难点。
</code></pre><p>3.第三方的使用</p>
<pre><code>第三方产厂商的sdk使用...
注意事项：兼容性、生产测试环境的隔离、bug收集、易用性
</code></pre><p>4.设计模式、数据结构</p>
<pre><code>设计模式：
一  什么是设计模式？
    （1）基本定义：设计模式（Design pattern）是一套被反复使用的代码设计经验的总结。使用设计模式的目的是为了可重用代码、让代码更容易被他人理解。设计模式是是软件工程的基石脉络，如大厦的结构一样
    （2）Design pattern的四大要素：模式名称（Name），问题（Question），解决方案（Solution），效果（Efftive）。
    （3）OO（面向对象）的六大原则：单一职责原则，开闭原则，里氏替换原则，依赖倒置原则，接口隔离原则，迪米特原则。
        单一职责原则：一个类中应该是一组相关性很高的函数，数据的封装。两个完全不一样的功能就不应该放在一个类中。
        开闭原则：对修改封闭，对扩展放开。
        里氏替换原则：抽象和继承；所有引用基类的地方必须能透明的使用其子类的对象。
        依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。
        接口隔离原则：将大接口改成多个小接口。
        迪米特原则：也称为最少知识原则，一个对象应该对另一个对象有最少的了解。
二 设计模式的分类
    设计模式分为三种类型：
    （1）创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。（口诀：单原建造者，东西二厂）
    （2）结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。（口诀：一器一桥一元一代理；装饰组合外观）
    （3）行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。（口诀：三者两器、一录一链一模板，状态策略命令）
三  Android中的设计模式
    （1）单例模式：
        简介：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
        示例：Android中的系统级服务都是通过容器的单例模式实现方式，以单例形式存在，减少了资源消耗。
        比如LayoutInflater Service，将这些服务以键值对的形式存储在一个HashMap容器中，用户使用时只需要根据key来获取到对应的ServiceFetcher，然后通过ServcieFetcher对象的getService函数来获取到具体的服务对象，第一次获取时会调用ServcieFetcher的createService函数创建服务对象，然后将该对象缓存到一个列表中，下次再取时直接从缓存中获取，避免重复创建对象，从而达到单例的效果。
    （2）抽象工厂模式：
        简介：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
        示例：Android底层对MediaPlayer的创建。MediaPlayerFactory是Android底层为了创建不同的MediaPlayer所定义的一个类。
    （3）工厂模式：
        简介：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
        示例：BitmapFactory位图工厂，专门用来将指定的图片转换为指定的位图Bitmap。
    （4）原型模式：
        简介：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
        示例：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了。在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。
    （5）建造者模式：
        简介：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
        示例：AlertDialog.Builder   ImageLoader的初始配置。
    （6）适配器模式：
        简介：将一个类的接口转换成客户希望的另外一个接口。
        示例：不同的数据提供者使用一个适配器来向一个相同的客户提供服务。
        ListView或GridView的Adapter。
    （7）桥接模式：
        简介：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
        示例：Window和WindowManager之间的关系。
        在FrameWork中Window和PhoneWindow构成窗口的抽象部分，其中Window类为该抽象部分的抽象接口，PhoneWindow为抽象部分具体的实现及扩展。而WindowManager则为实现部分的基类，WindowManagerImpl则为实现部分具体的逻辑实现。
    （8）装饰模式：
        简介：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。
        示例：Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper才是继承自Context。ContextWrapper就是我们找的装饰者。
    （9）组合模式：
        简介：将对象组合成树形结构以表示“部分-整体”的层次结构。
        示例：View和ViewGroup的组合
    （10）外观模式
        简介：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，统一编程接口。
        示例：ContextImpl
    （11）享元模式：
        简介：运用共享技术有效地支持大量细粒度的对象。
        示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。
    （12）代理模式：
        简介：为其他对象提供一个代理以控制对这个对象的访问。
        示例：所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。
    （13）观察者模式：
        简介：一个对象发生改变时，所有信赖于它的对象自动做相应改变。
        示例：我们可以通过BaseAdapter.registerDataSetObserver和BaseAdapter.unregisterDataSetObserver两方法来向BaseAdater注册、注销一个DataSetObserver。这个过程中，DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。事件通知也是观察者模式。
    （14）中介者模式：
        简介：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
        示例：Binder机制。
    (15)访问者模式:
        简介：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
        示例：编译时注解中的ElementVisitor中定义多个Visit接口，每个接口处理一种数据类型，这就是典型的访问者模式，访问者模式正好解决了数据结构和数据操作分离的问题，避免某些操作污染了数据对象类。
    （16） 解释器模式：
        简介：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
        示例：PackageParser这个类对AndroidManifest.xml这个配置文件的解析过程，
    （17）迭代器模式
        简介：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
        示例：在Android中除了各种数据结构体，如List，Map，等包含的迭代器以外，Android源码中也提供了迭代器遍历模式，比如数据库查询使用Cursor，当我们使用SQLiteDataBase的query方法查询数据库时，会返回一个Cursor游标对象，该游标对象实际上就是一个具体的迭代器。
    （18）备忘录模式
        简介：不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。
        示例：Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。
    （19）责任链模式
        简介：有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。
        示例:  责任链模式在Android源码中比较类似的实现莫过于对事件的分发处理，每当用户接触屏幕时候，Android都会将对应的事件包装成一个事件对象从ViewTree的顶部至上而下的分发传递。ViewGroup事件投递的递归调用就类似一条责任链，一旦寻找到责任者，那么就由责任者持有并消费该次事件，具体的体现在View的onTouchEvent方法中的返回值，如果OnTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对该事件持有。
    （20）状态模式：
        简介：状态发生改变时，行为改变。
        示例：View.onVisibilityChanged方法，就是提供了一个状态模式的实现，允许在View的visibility发生改变时，引发执行onVisibilityChanged方法中的动作。
    （21）策略模式
        简介：定义了一系列封装了算法、行为的对象，他们可以相互替换。
        示例：Java.util.List就是定义了一个增（add）、删（remove）、改（set）、查（indexOf）策略，至于实现这个策略的ArrayList、LinkedList等类，只是在具体实现时采用了不同的算法。但因为它们策略一样，不考虑速度的情况下，使用时完全可以互相替换使用。
    （22）命令模式
        简介：把请求封装成一个对象发送出去，方便定制、排队、取消。
        示例：Handler.post后Handler.handleMessage。
    （23）享元模式
        简介：运用共享技术有效地支持大量细粒度的对象。
        示例：Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。
数据：三个重要的接口与线程安全与有序无序
    1.List 列表
        arraylist、vector是线性表使用object数组作为容器去存储数据，长度动态增长。array是非同步的，vector是同步的。
        LinkedList是链表，链表随机位置插入、删除数据时比线性表快，遍历比线性表慢。
        ArrayList（非同步、非频繁删除时选择）、Vector（需同步时选择）、LinkedList（频繁在任意位置插入、删除时选择）
    2.Set 唯一集合
        Set结构其实就是维护一个Map来存储数据的，利用Map结构key值唯一性。
    3.Map 键值对应 key唯一
        HashMap
            结构的实现原理是将put进来的key-value封装成一个Entry对象存储到一个Entry数组中，位置（数组下标）由key的哈希值与数组长度计算而来。如果数组当前下标已有值，则将数组当前下标的值指向新添加的Entry对象。
        TreeMap
            是由Entry对象为节点组成的一颗红黑树，put到TreeMap的数据默认按key的自然顺序排序，new TreeMap时传入Comparator自定义排序。
        HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。
        HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。
        另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModif:icationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。
        由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。
        HashMap不能保证随着时间的推移Map中的元素次序是不变的。
    工具类：Collections
        集合的差集、并集、拷贝、排序等等
    数据结构：
        数组、有序数组、栈、队列、链表、二叉树、红黑树、2-3-4树、哈希表、堆、图；
        重点红黑树！！！&lt;-------------重点
</code></pre><p>5.多线程、图形、网络编程</p>
<pre><code>线程:
    一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。线程的实现方式有三种runnable（接口），thread（类），callable（接口可集成别的类）
守护线程：
    User Thread(用户线程)、DaemonThread(守护线程)。
    主线程中建立一个守护线程，当主线程结束时，守护线程也跟着结束。守护线程主要为了别的线程服务；当所有的用户线程都不存在才会自动退出。
线程状态：
    新建状态、就绪状态、运行状态、阻塞状态（等待阻塞；同步阻塞，线程获取同步锁失败；其他阻塞）、死亡状态；
线程同步：
    synchronized ：
        一 、修饰方法 public synchronized void saveValue（）{}；
        二 、同步方法  synchronized (this){index+=dex;}； 
    volatile：
        a：volatile关键字为域变量的访问提供了一种免锁机制 
           b：使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， 
        c：因此每次使用该域就要重新计算，而不是使用寄存器中的值 
        d：volatile不会提供任何原子操作，它也不能用来修饰final类型的变量
    ReentrantLock（类）：
        Lock lock = new ReentrantLock(); 
        lock.lock();  //上锁
        ...
        lock.unlock();  //解锁
    ThreadLocal管理变量：
        一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
        ThreadLocal() : 创建一个线程本地变量 
        get() : 返回此线程局部变量的当前线程副本中的值 
        initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot; 
        set(T value) : 将此线程局部变量的当前线程副本中的值设置为value
    LinkedBlockingQueue与ArrayBlockingQueue:
        Java并发中阻塞队列
    -------------------------------------------------
    -------------------------------------------------
    图形编程：
    hencoder.com ----&gt; 头2章
    -------------------------------------------------
    -------------------------------------------------
    网络编程:
        TCP：
            TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。
        UDP：
            UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。
            以上两个太特么难了，不整了
        Socket 编程:
            网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户端和服务端的连接。Socket是TCP/IP协议的一个十分流行的编程实现，一个Socket由一个IP地址和一个端口号唯一确定。 但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。
            Server端Listen(监听)某个端口是否有连接请求，Client端向Server端发出Connect(连接)请求，Server端向Client端发回Accept（接受）消息。一个连接就建立起来了。Server端和Client 端都可以通过Send，Write等方法与对方通信。 
            对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤： 
                （1） 创建Socket； 
                （2） 打开连接到Socket的输入/出流； 
                （3） 按照一定的协议对Socket进行读写操作； 　　
                （4） 关闭Socket。
</code></pre><p>6.动画、页面优化</p>
<pre><code>xml动画（alpha、scale、translate、rotate、set）：
    scale(fromXScale、toXScale、fromYscale、pivotX:&apos; 50、50%、50%p&apos;);
    alpha;
    rotate;
    translate;
    set;
Interpolator 插值器(系统默认):
    AccelerateDecelerateInterpolator
        在动画开始与介绍的地方速率改变比较慢，在中间的时候加速
    AccelerateInterpolator
        在动画开始的地方速率改变比较慢，然后开始加速
    AnticipateInterpolator 
        开始的时候向后然后向前甩
    AnticipateOvershootInterpolator
        开始的时候向后然后向前甩一定值后返回最后的值
    BounceInterpolator
        动画结束的时候弹起
    CycleInterpolator
        动画循环播放特定的次数，速率改变沿着正弦曲线
    DecelerateInterpolator
        在动画开始的地方快然后慢
    LinearInterpolator
        以常量速率改变
    OvershootInterpolator
        向前甩一定值后再回到原来位置
代码生成动画（Animation的子类实现）：
    不同的构造参数代表实现动画的不同属性，需要针对去查看
属性动画（Property Animator 包括 ValueAnimator 和 ObjectAnimator）： 
    ValueAnimator：
        TimeInterpolator:
            实现自定义插值器
        Evaluator（ 继承 TypeEvaluator）：
            动画进度的数值转换
        ArgbEvalutor：
            颜色数值转换器
        PointEvaluator ：
            Point点值返回
        ofObject:
            对象
    ObjectAnimator（派生自 ValueAnimator，能用他的所有方法）:
        public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) 实现方法；
        alpha,rotaion(rotation、rotationX、rotationY),translate(translationX、translationY),scale(scaleX、scaleY)是第二个参数的值，能够直接实现的动画效果；
        自定义ObjectAnimator主要是能够实现第二个参数的seter方式要名称一致（&quot;big&quot;--&gt;setBig(value)）；
    PropertyValuesHolder（ObjectAnimator.ofPropertyValuesHolder（...））:
        控制视图的单个属性，传如多个能够控制多种属性变换。
    Keyframe(关键帧，在某一时间的停留位置状态，为了照顾我等不会计算的人)：
        PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)；
        利用关键帧创建 PropertyValuesHolder 后，一定要记得设置自定义的 Evaluator；ofObject 来做动画的时候，都必须调用 frameHolder.setEvaluator 显示设置 Evaluator
LayoutAnimation：
    xml配置有效的字段：
        delay（animation动画的倍数）、
        animationOrder（顺序 normal、reverse、random）、
        animation
GridLayoutAnimation：
    rowDelay（每一行动画开始的延迟）、
    columnDelay（每一列动画开始的延迟）、
    directionPriority（方向优先级。取值为 row,collumn,none）、direction（left_to_right：列，从左向右开始动画 right_to_left ：列，从右向左开始动画 top_to_bottom：行，从上向下开始动画 bottom_to_top：行，从下向上开始动画）、
    animation；
animateLayoutChanges（api &gt;= 11）：
    以上2种的动画只是在创建的时候第一次才会有动画，再添加数据不会有动画出现；
    设置为true;
LayoutTransaction:
    用来添加自定义动画，否则animateLayoutChanges只是显示默认的动画；
    LayoutTransaction transitioner = new LayoutTransition();
    ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);  transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); 
    int transitionType：表示当前应用动画的对象范围，取值有：
        APPEARING —— 元素在容器中出现时所定义的动画。
        DISAPPEARING —— 元素在容器中消失时所定义的动画。
        CHANGE_APPEARING —— 由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画
        CHANGE_DISAPPEARING —— 当容器中某个元素消失，其它需要变化的元素所应用的动画
</code></pre><p>7.js、ES6、html5</p>
<pre><code>ES6：
新特性：
    变量声明const和let：
        之前使用var关键字生i没那个变量，无论声明在何处，都会视为声明在函数的最顶端，不在函数内，是在全局作用域的最顶端，es6后ley表示变量，const表示常量，let和const都是块级作用域（函数内部、或一个代码块内部，{}），const是一个常量，只要是指向得地址没改变就行，指向一个对象，对象得值改变能够接受；
    模板字符串：
        字符串中使用${name}进行格式化，``反引号换行拼接`************`,includes(),repeat(),startsWith(),endsWidth();
    函数默认参数：
        function action(num = 200){}；
    函数箭头函数：
        不需要function关键字来创建函数；
        省略return 关键字；
        继承当前上下文得this关键字；
        跟java得差不多
    扩展得对象功能：
        对象初始化简写：function person(name,age){
            return{name,age};
        };
        Object.assign(),浅拷贝
    数据访问结构：
        const(name,age)= pserson;
    Spread Operator展开运算符：
        三个点：...;  
        const color = [&apos;red&apos;, &apos;yellow&apos;]
        const colorful = [...color, &apos;green&apos;, &apos;pink&apos;]
        或
        const number = [1,2,3,4,5]
        const [first, ...rest] = number
    import和export：
        导入模块和导出模块：
        //全部导入
        import people from &apos;./example&apos;
        //有一种特殊情况，即允许你将整个模块当作单一对象进行导入
        //该模块的所有导出都会作为对象的属性存在
        import * as example from &quot;./example.js&quot;
        //导入部分
        import {name, age} from &apos;./example&apos;
        // 导出默认, 有且只有一个默认
        export default App
        // 部分导出
        export class App extend Component {};

        1.当用export default people导出时，就用 import people 导入（不带大括号）
        2.一个文件里，有且只能有一个export default。但可以有多个export。
        3.当用export name 时，就用import { name }导入（记得带上大括号）
        4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } 
        5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example
    Promise：
        同步的方式去写异步代码。
    Generators：
        生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。
        当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。
        // 生成器
         function *createIterator() {
            yield 1;
            yield 2;
            yield 3;
        }   
        // 生成器能像正规函数那样被调用，但会返回一个迭代器
        let iterator = createIterator();
        console.log(iterator.next().value); // 1
        console.log(iterator.next().value); // 2
        console.log(iterator.next().value); // 3
    Proxies:
        代理，监听数据对象变化。
</code></pre><p>8.区块链</p>
<pre><code>去中心化，概率值越大越不容易获取，sha64
</code></pre><p>9.http协议</p>
<pre><code>客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。
通用头域：
    Cache-Control:
        请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached;
        响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。
    Keep-Alive:
        KeepAliveTime:验证连接有效的频率。
    Date：
        消息发送的时间。
    Pragma：
        包含实现特定的指令
请求消息：
    请求头域可能包含下列字段Accept、Accept-Charset、Accept-Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。
相应消息：
    code值的返回状态意义--&gt;
    1xx:信息响应类，表示接收到请求并且继续处理
    2xx:处理成功响应类，表示动作被成功接收、理解和接受
    3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理
    4xx:客户端错误，客户请求包含语法错误或者是不能正确执行
    5xx:服务端错误，服务器不能正确执行一个正确的请求
Location响应头:
    Location响应头用于重定向接收者到一个新URI地址。
Server响应头:
    Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。
实体信息:
    请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。
Content-Type实体头:
    Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型
Content-Range实体头
    Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：
    Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth
</code></pre><p>10.websocket（js）</p>
<pre><code>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。
1.建立在 TCP 协议之上，服务器端的实现比较容易。
2.与HTTP协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3.数据格式比较轻量，性能开销小，通信高效。
4.可以发送文本，也可以发送二进制数据。
5.没有同源限制，客户端可以与任意服务器通信。
6.协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
var Socket = new WebSocket(url, [protocol] );
open    Socket.onopen    连接建立时触发
message    Socket.onmessage    客户端接收服务端数据时触发
error    Socket.onerror    通信发生错误时触发
close    Socket.onclose    连接关闭时触发
</code></pre><p>11.RESTful</p>
<pre><code>1.Rest架构的主要原则
    网络上的所有事物都被抽象为资源
       每个资源都有一个唯一的资源标识符
    同一个资源具有多种表现形式(xml,json等)
    对资源的各种操作不会改变资源标识符
    所有的操作都是无状态的
    符合REST原则的架构方式即可称为RESTful
</code></pre><p>12.react<br>13.glide<br>14.LeakCanary<br>15.dexclassloader<br>16.Android 热更新</p>
<pre><code>classloader：
    插件化还是组件化，都是基于系统的ClassLoader来设计的。只不过Android平台上虚拟机运行的是Dex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。
Android中的ClassLoader：
    BootClassLoader、URLClassLoader、PathClassLoader、DexClassLoader、DexClassLoader、BaseDexClassLoader，全部继承自ClassLoader；
    Android中默认无父构造器的传入情况下，默认父构造器是一个PathClassLoader，该类的父构造器是BootClassLoader，主要方法为loadClass（String className,boolean resolve）加载类，如果类是重复的就不会对类进行加载。

    BootClassLoader：
        与Java虚拟机中不同的是BootClassLoader是ClassLoader的内部类，由java实现，Android中的classLoader的最终父类，内部类不可见。
    URLClassLoader:
        加载jar文件，由于dalvik不能直接识别jar，在Android中无法使用这个加载器。
    BaseDexClassLoader：
        PathClassLoader与DexClassLoader都继承自BaseDexClassLoader，主要逻辑是在BaseDexClassLoader中完成。
        四个参数：
        dexPath,指目标类所在的APK或jar文件的路径,类装载器将从该路径中寻找指定的目标类,该类必须是APK或jar的全路径.如果要包含多个路径,路径之间必须使用特定的分割符分隔,特定的分割符可以使用System.getProperty(“path.separtor”)获得。上面&quot;支持加载APK、DEX和JAR，也可以从SD卡进行加载&quot;指的就是这个路径，最终做的是将dexPath路径上的文件ODEX优化到内部位置optimizedDirectory，然后，再进行加载的。
        File optimizedDirectory,由于dex文件被包含在APK或者Jar文件中,因此在装载目标类之前需要先从APK或Jar文件中解压出dex文件,该参数就是制定解压出的dex 文件存放的路径。这也是对apk中dex根据平台进行ODEX优化的过程。其实APK是一个程序压缩包，里面包含dex文件，ODEX优化就是把包里面的执行程序提取出来，就变成ODEX文件，因为你提取出来了，系统第一次启动的时候就不用去解压程序压缩包的程序，少了一个解压的过程。这样的话系统启动就加快了。为什么说是第一次呢？是因为DEX版本的也只有第一次会解压执行程序到 /data/dalvik-cache（针对PathClassLoader）或者optimizedDirectory(针对DexClassLoader）目录，之后也是直接读取目录下的的dex文件，所以第二次启动就和正常的差不多了。当然这只是简单的理解，实际生成的ODEX还有一定的优化作用。ClassLoader只能加载内部存储路径中的dex文件，所以这个路径必须为内部路径。
        libPath,指目标类中所使用的C/C++库存放的路径
        classload,是指该装载器的父装载器,一般为当前执行类的装载器，例如在Android中以context.getClassLoader()作为父装载器。
    DexClassLoader：
        四个参数：
        DexClassLoader支持加载APK、DEX和JAR，也可以从SD卡进行加载。
        上面说dalvik不能直接识别jar,DexClassLoader却可以加载jar文件,这难道不矛盾吗?其实在BaseDexClassLoader里对&quot;.jar&quot;,&quot;.zip&quot;,&quot;.apk&quot;,&quot;.dex&quot;后缀的文件最后都会生成一个对应的dex文件,所以最终处理的还是dex文件,而URLClassLoader并没有做类似的处理。
        一般我们都是用这个DexClassLoader来作为动态加载的加载器。
    PathClassLoader：
        三个参数：并无optimizedDirectory，直接设为null；
        PathClassLoader将optimizedDirectory置为Null,也就是没设置优化后的存放路径。其实optimizedDirectory为null时的默认路径就是/data/dalvik-cache 目录。
        PathClassLoader是用来加载Android系统类和应用的类，并且不建议开发者使用。
ART虚拟机的兼容性问题：
    Android Runtime（缩写为ART），在Android 5.0及后续Android版本中作为正式的运行时库取代了以往的Dalvik虚拟机。ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机。它与Dalvik的主要不同在于：Dalvik采用的是JIT技术，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而ART采用Ahead-of-time（AOT）技术，应用在第一次安装的时候，字节码就会预先编译成机器码，这个过程叫做预编译。ART同时也改善了性能、垃圾回收（Garbage Collection）、应用程序除错以及性能分析。但是请注意，运行时内存占用空间较少同样意味着编译二进制需要更高的存储。
    ART模式相比原来的Dalvik，会在安装APK的时候，使用Android系统自带的dex2oat工具把APK里面的.dex文件转化成OAT文件，OAT文件是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。ART模式的系统里，同样存在DexClassLoader类，包名路径也没变，只不过它的具体实现与原来的有所不同，但是接口是一致的。实际上，ART运行时就是和Dalvik虚拟机一样，实现了一套完全兼容Java虚拟机的接口。
</code></pre><p>17.Android插件化开发：</p>
<pre><code>代理（静态代理、动态代理）、hook、java反射;
java反射：
1.实例化Class对象，有三种方式，
    Class.forName(类名全路径); //通过Class的静态方法
    对象.getClass() //通过对象.getClass方法
    int.class //基本数据类型及基本数据类型的封装了，例如Integer
2.获取父类
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法
    Class&lt;?&gt; superclass = clazz.getSuperclass();
3.获取实现接口
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法
    Class&lt;?&gt;[] interfaces = clazz.getInterfaces()
4.获取指定参数构造函数及实例化
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法
    Constructor&lt;?&gt; constructor = clazz.getConstructor(Class&lt;?&gt;  ... class);//获取公共的
    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor()//获取私有的
    constructor.newInstance(Object args);
5.获取所有构造函数及构造参数的类型
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法
    Constructor&lt;?&gt;[] constructors = clazz.getConstructors();//公共的
    Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors()//包括私有的

     for (int i = 0; i &lt; constructors.length; i++) {
        Class&lt;?&gt; clazzs[] = constructors[i].getParameterTypes();//获取类型
        System.out.print(&quot;constructors[&quot; + i + &quot;] (&quot;);
        for (int j = 0; j &lt; clazzs.length; j++) {
            if (j == clazzs.length - 1)
                System.out.print(clazzs[j].getName());
            else
                System.out.print(clazzs[j].getName() + &quot;,&quot;);
        }
        System.out.println(&quot;)&quot;);
    }
6.通过无参实例化对象
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法          
    class.newInstance();
7.获取字段，修改字段
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法          

    Field field = clazz.getField(String name);//获取公共字段
    Field field = clazz.getDeclaredField(String name);//获取私有公共字段
    Field[] field = clazz.getFields();//获取所有公共字段
    Field[] field = clazz.getDeclaredFields();//获取包括私有所有字段

    Field field = clazz.getDeclaredField(&quot;heihei&quot;);
    field.setAccessible(true);//设置java取消访问检查，也就是说如果是私有的也可以访问,
    field.set(obj, &quot;Java反射机制&quot;);

8.获取方法,运行方法
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法          

    clazz.getMethod(String name ,Class&lt;?&gt; ... parame);//获取公共指定方法
    clazz.getDeclaredMethod(String name ,Class&lt;?&gt; ... parame)//获取私有指定方法
    clazz.getMethods()//获取公共所有方法
    clazz.getDeclaredMethods();//获取包括私有全部方法

    Method method = clazz.getMethod(&quot;add&quot;);
    method.invoke(clazz.newInstance());

    method = clazz.getMethod(&quot;getInfo&quot;, int.class, String.class);
    method.setAccessible(true)//设置java取消访问检查，也就是说如果是私有的也可以访问,
    method.invoke(clazz.newInstance(), 20, &quot;张三&quot;);
9.获取数组或者list中的类型,如果不是数组或集合返回null
    Class&lt;?&gt; clazz  = Class.forName(类名全路径); //通过Class的静态方法  
    Class&lt;?&gt; componentType = clazz.getComponentType();
</code></pre><p>18.bitmap的重复使用<br>19.LeakCanary<br>20.activiti manager ；window manager； content providers； package manager ；resource manager ；view system:<br>21.View点击事件：</p>
<pre><code>1 getAction:触摸动作的原始32位信息，包括事件的动作，触控点信息： 
    一个点击事件的所有信息，坐标点、触摸事件、是哪个手指头点的
2 getActionMask:触摸的动作,按下，抬起，滑动，多点按下，多点抬起：
    单纯的触摸事件
3 getActionIndex:触控点信息：
    触摸点
都会回调到onTouchEvent()方法中，多点触摸处就根据3-&gt;2

旋转手势：
    GestureDetector与ScaleGestureDetector；
</code></pre><p>22.广播：</p>
<pre><code>本地广播：LocalBroadcastManager，只在应用内接受发送广播；
普通广播有序广播：普通是异步方式全部发送，有序广播按照顺序发送每次只给一个发送，有序广播能够在被接收到后反馈数据、终止继续下发;
</code></pre><p>23.线程池：(<a href="https://blog.csdn.net/tuke_tuke/article/details/51353925" target="_blank" rel="noopener">https://blog.csdn.net/tuke_tuke/article/details/51353925</a> 说的比较详细)</p>
<pre><code>ExecutorService：
    Executor接口是Executor框架中最基础的部分，定义了一个用于执行Runnable的execute方法，它没有实现类只有另一个重要的子接口ExecutorService；
    ExecutorService接口继承自Executor接口，定义了终止、提交,执行任务、跟踪任务返回结果等方法
    1.execute（Runnable command）：履行Ruannable类型的任务,
    2.submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future对象
    3.shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,
    4.shutdownNow（）：停止所有正在履行的任务并封闭办事。
    5.isTerminated（）：测试是否所有任务都履行完毕了。,
    6.isShutdown（）：测试是否该ExecutorService已被关闭
Executors:
    负责生成各种类型的ExecutorService线程池实例;
    +newFixedThreadPool(numberOfThreads:int):（固定线程池）ExecutorService
        创建一个固定线程数量的线程池，并行执行的线程数量不变，线程当前任务完成后，可以被重用执行另一个任务
    +newCachedThreadPool():（可缓存线程池）ExecutorService
        创建一个线程池，按需创建新线程，就是有任务时才创建，空闲线程保存60s，当前面创建的线程可用时，则重用它们
    +new SingleThreadExecutor();
        （单线程执行器）线程池中只有一个线程，依次执行任务
    +new ScheduledThreadPool()：
        线程池按时间计划来执行任务，允许用户设定执行任务的时间
    +new SingleThreadScheduledExcutor();
        线程池中只有一个线程，它按规定时间来执行任务
Feature:
    Future代表异步任务的执行结果;
    Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果;
    +cancel
        方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。
        参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。
    +isCancelled
        方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。
    +isDone
        方法表示任务是否已经完成，若任务完成，则返回true；
    +get()
        方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；
    +get(long timeout, TimeUnit unit)
        用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。
    也就是说Future提供了三种功能：
    　　1）判断任务是否完成；
    　　2）能够中断任务；
    　　3）能够获取任务执行结果。
</code></pre><p>24.OAuth2:</p>
<pre><code>基本流程：
    （A）用户打开客户端以后，客户端请求资源所有者（用户）的授权。
    （B）用户同意给予客户端授权。
    （C）客户端使用上一步获得的授权，向认证服务器申请访问令牌。
    （D）认证服务器对客户端进行认证以后，确认无误，同意发放访问令牌。
    （E）客户端使用访问令牌，向资源服务器申请获取资源。
    （F）资源服务器确认令牌无误，同意向客户端开放资源。
授权的四种模式：
    授权码模式（authorization code）
    简化模式（implicit）
    密码模式（resource owner password credentials）
    客户端模式（client credentials）
</code></pre><p>25.scrollView嵌套ListView滑动冲突显示不正确:</p>
<pre><code>https://www.jianshu.com/p/9abf6a874feb
</code></pre><p>26.一天一面：</p>
<pre><code>https://www.jianshu.com/p/1d3a2227fb72
知识点是挺基础在平时也是挺使用的，需要定期看下
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/26/ewGroup一些相关的类/" rel="next" title="ViewGroup一些相关的类">
                <i class="fa fa-chevron-left"></i> ViewGroup一些相关的类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/27/va代理/" rel="prev" title="java代理">
                java代理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大帅</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">侯大帅</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">29.4k</span>
  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('6');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


</body>
</html>
